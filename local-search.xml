<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CDN内容分发网络简介</title>
    <link href="/2024/01/27/CDN/"/>
    <url>/2024/01/27/CDN/</url>
    
    <content type="html"><![CDATA[<h1 id="CDN-Content-Delivery-Network"><a href="#CDN-Content-Delivery-Network" class="headerlink" title="CDN Content Delivery Network"></a>CDN Content Delivery Network</h1><p>CDN 是用来优化网络资源请求的时间的</p><h2 id="优化资源访问速度"><a href="#优化资源访问速度" class="headerlink" title="优化资源访问速度"></a>优化资源访问速度</h2><p>请求资源的速度和资源所在的服务器与我们的地理距离有关，如果距离过远，资源从服务器发送到我们这里所需时间就会很久。</p><p>为了解决这一问题，可以构建一个内容分发网络 CDN，请求资源的时候会优先询问距离我们较近的服务器有没有该资源，如果没有，较近的服务器再向上层层查找，直到找到我们要访问的资源所在的原服务器，获取该资源，缓存到较近的服务器最后再发送给我们。</p><p>这样一来，等到下次再请求该资源的时候，就可以通过 CDN 直接从已经缓存过资源、并且距离非常近的服务器上获取资源，大大减少了网络请求时间</p><h2 id="异地容灾"><a href="#异地容灾" class="headerlink" title="异地容灾"></a>异地容灾</h2><p>使用了 CDN 后，浏览器输入 url 通过 DNS 将域名解析为 IP 的过程会发生变化，第三步不再是查找权威域名服务器，而变成了智能 DNS</p><p><img src="/img/computer_network/CDN/image-20240128190751726.png" alt="image-20240128190751726"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>监控整个网络中浏览器的流量，调度分配每个服务器的任务，使得 CPU 占用率、负载基本均衡</p><p><img src="/img/computer_network/CDN/image-20240128191142254.png" alt="image-20240128191142254"></p>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器同源策略和跨域限制</title>
    <link href="/2024/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%E9%99%90%E5%88%B6/"/>
    <url>/2024/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="URL-简介"><a href="#URL-简介" class="headerlink" title="URL 简介"></a>URL 简介</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL">https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL</a></p><p>URL 由<strong>协议（通常都是 HTTP 协议或是 HTTP 协议的安全版，即 HTTPS）、服务器地址（可以是 IPv4 IPv6 地址，也可以是域名）和端口</strong>三个必须部分，以及一些非必需选项共同组成。</p><p><img src="/img/computer_network/CORS/mdn-url-all.png" alt="mdn-url-all"></p><h1 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h1><p>如果两个页面的<strong>协议，域名和端口</strong>都相同，则两个页面具有相同的源。</p><h1 id="浏览器的同源策略（桌面端通信没有同源策略限制）"><a href="#浏览器的同源策略（桌面端通信没有同源策略限制）" class="headerlink" title="浏览器的同源策略（桌面端通信没有同源策略限制）"></a>浏览器的同源策略（桌面端通信没有同源策略限制）</h1><p><strong>同源策略（英文全称 Same origin policy）是浏览器提供的一个安全功能</strong>。</p><p>MDN 官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 通俗的理解：浏览器规定，A 网站的 JavaScript，不允许和非同源的网站 C 之间，进行资源的交互，例如：</p><p>① 无法读取非同源网页的浏览器缓存如 Cookie、LocalStorage 和 IndexedDB</p><p>② 无法接触非同源网页的 DOM</p><p>③ 无法向非同源地址发送 Ajax 请求</p><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>同源指的是两个 URL 的协议、域名、端口一致，反之，则是跨域。</p><p>出现跨域的根本原因：浏览器的同源策略不允许非同源的 URL 之间进行资源的交互。</p><p>网页：<a href="http://www.test.com/index.html">http://www.test.com/index.html</a></p><p>接口：<a href="http://www.api.com/userlist">http://www.api.com/userlist</a></p><p><strong>浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器的 Ajax 引擎拦截，无法被页面获取到！</strong></p><p><img src="/img/computer_network/CORS/browser-origin-strategy.png" alt="browser-origin-strategy"></p><h1 id="浏览器跨域限制的解决方式"><a href="#浏览器跨域限制的解决方式" class="headerlink" title="浏览器跨域限制的解决方式"></a>浏览器跨域限制的解决方式</h1><p>现如今，实现跨域数据请求，有四种解决方案，分别是 JSONP、Proxy、CORS 和 nginx 代理。</p><h3 id="前后端协商-JSONP"><a href="#前后端协商-JSONP" class="headerlink" title="前后端协商 JSONP"></a>前后端协商 JSONP</h3><p>出现的早，兼容性好（兼容低版本 IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。 缺点是<strong>只支持 GET 请求</strong>，不支持 POST 请求。</p><h3 id="前端解决——前端代理"><a href="#前端解决——前端代理" class="headerlink" title="前端解决——前端代理"></a>前端解决——前端代理</h3><p>仅能在开发环境下配合 webpack、vite、rollup 等前端构建打包工具使用。注意：生产环境需要配合 nginx 代理</p><h3 id="后端解决——CORS"><a href="#后端解决——CORS" class="headerlink" title="后端解决——CORS"></a>后端解决——CORS</h3><p>出现的较晚，它是 W3C 标准，<strong>属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容 某些低版本的浏览器</strong>。有安全请求、非安全请求和携带凭据的请求三种</p><h3 id="运维端解决——ngnix-代理"><a href="#运维端解决——ngnix-代理" class="headerlink" title="运维端解决——ngnix 代理"></a>运维端解决——ngnix 代理</h3><p>在 config 文件中配置 location</p>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>same origin policy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器输入url后发生了什么</title>
    <link href="/2024/01/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2024/01/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-DNS-域名解析"><a href="#1-DNS-域名解析" class="headerlink" title="1.DNS 域名解析"></a>1.DNS 域名解析</h1><p><img src="/img/computer_network/after_type_url/DNS.png" alt="DNS"></p><p><img src="/img/computer_network/after_type_url/query-domain-name-server.png" alt="query-domain-name-server"></p><h2 id="2-发送网络请求，三次握手建立-TCP-连接"><a href="#2-发送网络请求，三次握手建立-TCP-连接" class="headerlink" title="2.发送网络请求，三次握手建立 TCP 连接"></a>2.发送网络请求，三次握手建立 TCP 连接</h2><p>历经 OSI 七层网络模型逐步发送网络请求，最重要的是在传输层经过三次握手建立可靠的 TCP 连接，最后在应用层发送 HTTP 请求。</p><p>请求主要分为三部分：<strong>method headers body</strong></p><p>method 方法除了简单的 get post 之外还有遵从 restful 规范的 put delete patch 等方法，需要注意的是 options，是发送 preflight</p><p>预检请求的方法，如果一个 HTTP Request 不存从以下两点安全性要求：</p><ol><li><p>安全的方法：GET POST HEAD</p></li><li><p>安全的 headers：仅允许自定义下列 header：</p><ul><li>Accept</li><li>Accept- Language</li><li>Content-Language</li><li>Content-Type 的值为 application&#x2F;x-www-form-urlencoded，multipart&#x2F;form-data 或 text&#x2F;plain。</li></ul></li></ol><p>浏览器基于安全性考虑就会发送 preflight（预检请求，方法不是 POST&#x2F;GET 等，而是 OPTIONS），通过之后才会发送真正的请求</p><p><img src="/img/computer_network/after_type_url/image-20240202191157031.png" alt="image-20240202191157031"></p><h2 id="3-浏览器的强缓存和协商缓存"><a href="#3-浏览器的强缓存和协商缓存" class="headerlink" title="3.浏览器的强缓存和协商缓存"></a>3.浏览器的强缓存和协商缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>第一次成功发送请求并且成功获取响应之后，如果后台设置了强缓存，会强制浏览器将服务端提供的资源缓存在硬盘或者内存中。</strong></p><p>下次刷新浏览器发送同样的请求，如果没有超出浏览器缓存的时间限制，浏览器会直接返回请求内容，不会再通知服务端、请求服务端。</p><p>如果超出了 max-age 或 expires 规定的时间，服务器强缓存的资源就过期了。</p><p>max-age 的优先级高于 expires，前者是 HTTP1.1 支持，后者 HTTP1.0 支持。</p><p><img src="/img/computer_network/after_type_url/strong-cache.png" alt="strong-cache"></p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当服务端发现资源的最后修改时间 Last-Modified 和 If-Modified-Since 值相等，代表资源从该时间之后从未改变过，返回<strong>304 状态码和空响应体</strong>，浏览器拿到后知道原本可能过期的强缓存内容还可以继续使用。</p><p>如果值不相等，说明资源改变了，就会返回 200 状态码，响应体内为最新资源</p><h2 id="4-四次挥手断开-TCP-连接"><a href="#4-四次挥手断开-TCP-连接" class="headerlink" title="4.四次挥手断开 TCP 连接"></a>4.四次挥手断开 TCP 连接</h2><p><img src="/img/computer_network/after_type_url/image-20240202191126170.png" alt="image-20240202191126170"></p><h2 id="5-HTML-页面开始渲染"><a href="#5-HTML-页面开始渲染" class="headerlink" title="5.HTML 页面开始渲染"></a>5.HTML 页面开始渲染</h2><h3 id="绘制-DOM-树"><a href="#绘制-DOM-树" class="headerlink" title="绘制 DOM 树"></a>绘制 DOM 树</h3><p>HTML 解析器将超文本和标签解析成 DOM 树，绘制成一棵<strong>抽象语法树 AST</strong></p><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>渲染引擎将 CSS 样式表转换成浏览器可以理解的 style sheets，计算出 DOM 节点的样式</p><p>CSS 样式来源主要有三种：内嵌、内联、外联</p><p>CSS 文本中诸如 2em、blue 等无法直接被渲染引擎理解的内容会先经过属性值标准化的过程，转化为能被理解的标准值</p><p>然后再处理样式的继承和层叠，这个过程叫做 CSSOM 的构建过程</p><h3 id="回流（Reflow）和大小、宽高相关的一定是回流"><a href="#回流（Reflow）和大小、宽高相关的一定是回流" class="headerlink" title="回流（Reflow）和大小、宽高相关的一定是回流"></a>回流（Reflow）和大小、宽高相关的一定是回流</h3><p>当 render tree 中部分或全部元素的<strong>尺寸、结构或者某些属性</strong>发生改变时，<strong>浏览器重新渲染部分或全部文档的过程被称为回流。</strong></p><p>会导致回流的操作：</p><ul><li>页面首次渲染</li><li>浏览器窗口大小改变</li><li>元素尺寸或位置改变</li><li>元素字体大小改变</li><li>DOM 元素增删</li><li>激活 CSS 伪类</li></ul><p>一些常用且会导致回流的属性和方法：</p><ul><li>clientWidth clientHeight clientTop clientLeft</li><li>offsetWdith offsetHeight offsetTop offsetLeft</li><li>scrollWidth scrollHeight scrollTop scrollLeft</li><li>getBoundingClientRect</li></ul><h3 id="重绘（Repaint）绘色"><a href="#重绘（Repaint）绘色" class="headerlink" title="重绘（Repaint）绘色"></a>重绘（Repaint）绘色</h3><p>元素的 color、background color 等属性变化时，浏览器会重新绘制</p><h3 id="V8-解析-javascript"><a href="#V8-解析-javascript" class="headerlink" title="V8 解析 javascript"></a>V8 解析 javascript</h3><p>V8 解释器基于 JIT（Justin Runtime）实现</p><p><img src="/img/computer_network/after_type_url/image-20240202191101874.png" alt="image-20240202191101874"></p><h4 id="为什么不把-js-代码直接编译成机器码，而是有中间的字节码？"><a href="#为什么不把-js-代码直接编译成机器码，而是有中间的字节码？" class="headerlink" title="为什么不把 js 代码直接编译成机器码，而是有中间的字节码？"></a>为什么不把 js 代码直接编译成机器码，而是有中间的字节码？</h4><p>因为浏览器的运行环境可能不同，比如操作系统、CPU 硬件资源可能不同，为了实现跨平台的兼容通用，JS 代码统一解析成字节码，字节码的解释器和编译器适配各个平台，最终编译成机器码，由浏览器调度硬件资源执行指令</p>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>browser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP三次握手与四次挥手</title>
    <link href="/2024/01/25/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2024/01/25/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-基础知识"><a href="#TCP-基础知识" class="headerlink" title="TCP 基础知识"></a>TCP 基础知识</h1><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的<strong>传输层通信协议</strong>。</p><p>TCP 连接是用于保证可靠性和流量控制维护的某些状态信息的组合，包括 Socket、序列 号和窗口大小</p><p>TCP 四元组可以唯一的确定一个连接：源地址、源端口、目的地址、目的端口</p><h1 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>seq（sequence number），通过 sequence initial algorithm 随机生成的<br>ack（acknowledgement number），确认号 ack&#x3D;seq+1<br>ACK（acknowledgement）确定确认号有效<br>SYN（synchronous）发起新连接</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><img src="/img/computer_network/browser-origin/image-20240202191157031.png" alt="image-20240202191157031"></p><p><img src="/img/computer_network/browser-origin/image-20240202191822606.png" alt="image-20240202191822606"></p><h1 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h1><h2 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h2><p>seq（sequence number），通过 sequence initial algorithm 随机生成的<br>ack（acknowledgement number），确认号 ack&#x3D;seq+1<br>ACK（acknowledgement）确定确认号有效<br>SYN（synchronous）发起新连接<br>FIN（FINISH）完成</p><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><p><img src="/img/computer_network/browser-origin/image-20240202191126170.png" alt="image-20240202191126170"></p><p><img src="/img/computer_network/browser-origin/image-20240202191750514.png" alt="image-20240202191750514"></p><h3 id="等待阶段-2"><a href="#等待阶段-2" class="headerlink" title="等待阶段 2"></a>等待阶段 2</h3><p>FIN_WAIT_2 会处理还没有完成的任务，直到所有的任务处理完毕，才会发送第三次挥手</p><h3 id="超时等待状态持续-1-～-4-分钟，存在的原因？"><a href="#超时等待状态持续-1-～-4-分钟，存在的原因？" class="headerlink" title="超时等待状态持续 1 ～ 4 分钟，存在的原因？"></a>超时等待状态持续 1 ～ 4 分钟，存在的原因？</h3><p>这是为了保证服务端收到 ACK 包。</p><p>假设如果没有 2MSL 的等待时间，ACK 包丢失了，那服务端将永远不会断开连接。</p><p>有了 2MSL，如果一旦发生丢包将会进行超时重传，实现可靠连接。</p>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mini-react学习总结</title>
    <link href="/2024/01/21/mini-react%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/21/mini-react%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我参与<a href="https://github.com/cuixiaorui">崔大</a>发起的“mini-react 游戏副本”完整课程后的思路总结、技巧收获总结以及心得感悟。</p><p>思路总结重在阐述解决的问题和实现的大致思路，具体代码和详细的工作流程解释可见<a href="https://github.com/hugtyftg/mini-react%E3%80%82">https://github.com/hugtyftg/mini-react。</a></p><p>技巧收获重在分享令我醍醐灌顶的方法和技巧。</p><p>心得感悟重在记录我在整个学习过程中的感受和自我审视。</p><h1 id="mini-react-实现思路总结"><a href="#mini-react-实现思路总结" class="headerlink" title="mini-react 实现思路总结"></a>mini-react 实现思路总结</h1><h2 id="jsx-到-vdom-的转换"><a href="#jsx-到-vdom-的转换" class="headerlink" title="jsx 到 vdom 的转换"></a>jsx 到 vdom 的转换</h2><p>react 中的 jsx 语法本质上是 createElement 的语法糖，在 vite 中，esbuild 自动寻找当前引入的 React 模块中的 createElement 函数，将 jsx 语法用该函数解析为 vdom。</p><p>react 将除了标签本身的所有内容都看作 props，因此，vdom 的基本结构如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">VirtualDOM</span> &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;string&#x27;</span>;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">children</span>: <span class="hljs-title class_">VirtualDOM</span>[] | [];<br>    [<span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>vdom 按照内容可以粗浅分为两类，一种是没有实际文本内容标签构成的元素节点，另一类是现实文本内容的文本节点，因此 createElement 函数要兼容这两种情况。</p><h2 id="vdom-渲染为真实-DOM"><a href="#vdom-渲染为真实-DOM" class="headerlink" title="vdom 渲染为真实 DOM"></a>vdom 渲染为真实 DOM</h2><p>渲染过程可以抽象成 3 个步骤</p><ol><li>创建 dom</li><li>设置 props</li><li>添加 dom</li></ol><p>在每一步内具体考虑实现细节，比如 dom 创建时候要根据 vdom 的 type，props 要分成 children、style 和剩余 props 这三种情况处理</p><h2 id="微任务拆分调度"><a href="#微任务拆分调度" class="headerlink" title="微任务拆分调度"></a>微任务拆分调度</h2><p>对于浏览器中 JS 单线程执行的工作方式而言，一旦 DOM 树过于复杂，就会出现严重的界面渲染卡顿。</p><p>为了解决这一问题，我们可以把渲染整棵树这样的宏观庞大任务拆分成多个以渲染单 DOM 为目标的微任务，将微任务塞到浏览器的空闲时间内依次执行，充分利用计算资源。这就意味着要将非线形的 DOM 树形结构转换成一个线性的微任务执行队列，执行完一个任务之后返回下一个任务。因此选用链表，基于每个 vdom 节点创建微任务的执行单元——fiber，采用 child -&gt; sibling -uncle 这种类似树的深度优先前序遍历的顺序将 DOM 树转换成一个 fiber 队列，在浏览器空余时间内不断地执行任务、返回下一个任务直至终结。</p><h2 id="统一提交"><a href="#统一提交" class="headerlink" title="统一提交"></a>统一提交</h2><p>我们拆分出来的微任务会在浏览器的每个空闲时间片内执行，但如果在一个空闲时间片内，当前任务没有完全完成、dom 节点没有彻底创建完毕的时候，空闲时间就已经使用殆尽，任务就此中断。只有过了一段时间、到了下一次出现空闲时间片的时候，才会再次执行上次的遗留任务。这样一来，用户只会看到界面只出现一部分 DOM 而不是完整的 DOM，过了一段时间后才会陆续出现其他 DOM，也就是前端视觉卡顿。</p><p>该问题的本质是浏览器内核在执行任务的过程中具有异步性，以一种不可预知的速度执行每一个任务，因此空闲时间的出现以及对应 callback 的调用也是不可预估、时有时无的。如果在这样的时间内安排视觉呈现的工作，难免会出现断断续续的卡顿渲染，正如 MDN 官方文档对该 api 的注解一样：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E7%A9%BA%E9%97%B2%E5%9B%9E%E8%B0%83"><strong>避免在空闲回调中改变 DOM</strong>。空闲回调执行的时候，当前帧已经结束绘制了，所有布局的更新和计算也已经完成。如果你做的改变影响了布局，你可能会强制停止浏览器并重新计算，而从另一方面来看，这是不必要的。如果你的回调需要改变 DOM，它应该使用 Window.requestAnimationFrame() 来调度它。</a></p><p>因此只需要在这些时间片内进行计算工作，在链表计算处理结束的时候统一提交、执行真实 dom 的挂载即可。</p><h2 id="函数组件的解析和处理"><a href="#函数组件的解析和处理" class="headerlink" title="函数组件的解析和处理"></a>函数组件的解析和处理</h2><p>函数组件本质上是一个函数，执行函数组件的过程就是执行该函数的过程。函数组件没有具体意义，更像是一个需要“打开的盒子”，只有运行函数、打开盒子之后，我们才能得到想要的 dom 元素，所以对于没有盒子包裹的普通组件和有盒子包裹的函数组件在处理时并不相同：</p><p>前者在没有 dom 时候可以创建 dom、设置非 props 的属性、对 children 递归处理，而后者因为自身无实意，只能递归处理 children，并且需要通过<code>[fiber.type(props)]</code>才能得到 children 数组。</p><p>FC fiber 没有创建 dom 这一点为 fiber 任务执行过程中统一提交时挂载 DOM 的逻辑埋下隐患：</p><ol><li>没有 dom 无法挂载</li><li>没有 dom，不能作为 parent 被其他 dom 挂载</li></ol><p>处理方式为：</p><ol><li>有 dom 的 fiber 才会挂载到 parent.dom 上</li><li>parent.dom 为空时一直向上寻找，直到有 dom 为止</li></ol><h2 id="更新-props"><a href="#更新-props" class="headerlink" title="更新 props"></a>更新 props</h2><p>更新 props 意味着创建一棵新的 vdom 树，将新旧节点一一对比，再处理新旧不同的情况（仅仅考虑 dom 树的属性变化）。</p><h3 id="如何在不再次传入-el-和-container-的前提下重建-vdom-树呢？"><a href="#如何在不再次传入-el-和-container-的前提下重建-vdom-树呢？" class="headerlink" title="如何在不再次传入 el 和 container 的前提下重建 vdom 树呢？"></a>如何在不再次传入 el 和 container 的前提下重建 vdom 树呢？</h3><p>显而易见，在 render 的统一提交阶段结束之后保存 root 即可。</p><h3 id="如何对比新旧节点？"><a href="#如何对比新旧节点？" class="headerlink" title="如何对比新旧节点？"></a>如何对比新旧节点？</h3><p>之前保存的 root 实际上也是旧 DOM 的 root，因此在构建新 vdom 树、构建新 fiber 微任务队列的时候，同样递归遍历旧的 vdom 树、旧的 fiber 任务队列，通过 alternate 指针将新旧节点联系起来即可（这里考虑的新旧 vdom 树没有节点的变化，仅仅是属性的变化）。</p><p>并且可以在递归处理 children 的时候，根据 fiber.alternate.child 是否为空判断当前是初始化渲染阶段还是更新阶段，并分别给创建出来的 fiber 添加 placement 或 update 的 effectTag 标记，方便 diff props 处理。</p><p><img src="/img/react/mini-react/09-alternate-vdom-tree.png" alt="Alt text"></p><p><img src="/img/react/mini-react/09-alternate-linkedlist.png" alt="Alt text"></p><h3 id="diff-props"><a href="#diff-props" class="headerlink" title="diff props"></a>diff props</h3><p>在边创建新 fiber 边构建 alternate 的过程中，对比 props 会出现三种情况：</p><ol><li>old 有 new 没有 删除</li><li>new 有 old 没有 添加</li><li>new 有 old 有 值不同 更新</li></ol><p>后两种情况可以何必为一种：new 有 old 有，值不同，更新（old 没有改 prop 的话，取值结果是 undefined）。这三种情况通过分别遍历一次新旧 props 即可完成</p><p>在统一提交阶段已经执行了 dom 的挂载，同理，diff props 也应该在 commit 阶段执行。根据 fiber.effectTag，如果 placement 则说明是初始化渲染阶段，应该执行挂载 dom 的任务；如果是 update 说明是更新阶段，更新 props 即可。</p><h2 id="性能优化——更新-props-应该“指哪打哪”而非“从头再来”"><a href="#性能优化——更新-props-应该“指哪打哪”而非“从头再来”" class="headerlink" title="性能优化——更新 props 应该“指哪打哪”而非“从头再来”"></a>性能优化——更新 props 应该“指哪打哪”而非“从头再来”</h2><p>当前的更新逻辑是根据保存的 root 再重新创建一次树，但是就算某一个子组件没有更新（没有使用其他组件传来的、会发生变化的 prop，并且自身确实也没有更新），对应的子树还是会重新创建。最终某个子组件的更新引起了整个 app 的重新执行，造成巨大的计算资源浪费。</p><p>因此在更新时应该重新构建的仅仅是发生变化的函数组件所对应的子树，<strong>起点为 FC fiber，终点为 FC 的最后一个节点，也就是 FC fiber 的 sibling</strong>。</p><h3 id="起点是通过闭包保存的-FC-fiber"><a href="#起点是通过闭包保存的-FC-fiber" class="headerlink" title="起点是通过闭包保存的 FC fiber"></a>起点是通过闭包保存的 FC fiber</h3><p>正是由于函数组件具有需要执行的特点，我们可以将更新的粒度缩小到每个 FC，在 fiber 微任务队列执行到当前 FC 所在的 fiber 时（进入 handleFunctionComponent 时），可以使用闭包获取当前组件的 fiber，以便作为下一次使用（也就是更新时）的起点。</p><h3 id="结束点无疑是更新起点-FC-fiber-sibling"><a href="#结束点无疑是更新起点-FC-fiber-sibling" class="headerlink" title="结束点无疑是更新起点 FC fiber.sibling"></a>结束点无疑是更新起点 FC fiber.sibling</h3><p>在兄弟存在的情况下，如果下一个要执行的 fiber 就是兄弟，那么应该立即停止更新，将 nextWorkOfUnit 设置为 undefined 即可终止；如果兄弟不存在，nextWorkOfUnit 也会是 undefined，也会终止。</p><h2 id="更新-children"><a href="#更新-children" class="headerlink" title="更新 children"></a>更新 children</h2><p>上面的更新只考虑了新旧 dom 树没有 dom 增删变化、只有除 children 外的 props 的变化的情况，涉及到 children 的变化可能有两种情况：</p><ol><li>children 节点总数没有变化，新旧 fiber 队列等长（比如少了一个 div，多了一个 p）</li><li>children 节点总数发生变化，新旧 fiber 队列不等长（最常见）</li></ol><h3 id="新旧-fiber-队列等长度"><a href="#新旧-fiber-队列等长度" class="headerlink" title="新旧 fiber 队列等长度"></a>新旧 fiber 队列等长度</h3><p><img src="/img/react/mini-react/equal-length-children.png" alt="Alt text"></p><p>按照原先的逻辑，如果监测到新旧节点 type 不同的时候，认为当前处在初始更新阶段，因此添加新节点，而没有删除旧节点。这样潦草的判断在哪里自相矛盾呢？</p><p>对了，如果真的认为是初始化更新，oldFiberChild 就应该为空值，但是显然并不为空值。所以可以在新旧节点不同内再根据 oldFiberChild 是否为空，判断当前是真的 placement，还是有 dom 变化的 update。对于前者，现在的统一提交处理已经足够了，对于后者，统一提交前还需要删除旧节点。</p><p>这个功能的实现过程是螺旋上升的，具体可见<a href="#开发三驾马车之一按图索骥实现基础功能">开发三驾马车</a>中的叙述</p><h3 id="新旧-fiber-队列不等长度"><a href="#新旧-fiber-队列不等长度" class="headerlink" title="新旧 fiber 队列不等长度"></a>新旧 fiber 队列不等长度</h3><p><img src="/img/react/mini-react/unequal-children.png" alt="Alt text"></p><p><img src="/img/react/mini-react/unequal-length-linked-list.png" alt="Alt text"></p><p>forEach 遍历新 vdom 树的时候 oldFiberChild 也会更新（重新指向 oldFiberChild.sibling）</p><p>如果新旧子树相同，forEach 结束时，oldFiberChild.sibling 为 undefined，oldFiberChild 被更改为 undefined。</p><p>但是如果 oldFiberChild 仍不为 undefined，说明新旧子树并不相同，多余的子树需要在统一提交阶段被删除。</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initial</span>) &#123;<br>  <span class="hljs-comment">// state</span><br>  <span class="hljs-keyword">let</span> stateHook = &#123;<br>    <span class="hljs-attr">state</span>: initial,<br>  &#125;;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">action</span>) &#123;<br>    <span class="hljs-comment">// 修改state</span><br>    stateHook.<span class="hljs-property">state</span> = <span class="hljs-title function_">action</span>(stateHook.<span class="hljs-property">state</span>);<br>    <span class="hljs-comment">// 给wipRoot重新赋值，推动requestIdleCallback(workLoop)重新生成一棵DOM树，从而更新视图</span><br>    <span class="hljs-comment">// currentFiber为微任务队列执行到这个FC fiber时通过wipFiber获取到的闭包</span><br>    wipRoot = &#123;<br>      ...currentFiber,<br>      <span class="hljs-attr">alternate</span>: currentFiber,<br>    &#125;;<br>    nextWorkOfUnit = wipRoot;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [stateHook.<span class="hljs-property">state</span>, setState];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-action-为函数的-useState"><a href="#实现-action-为函数的-useState" class="headerlink" title="实现 action 为函数的 useState"></a>实现 action 为函数的 useState</h3><p>但是这样做有一个问题，在初始渲染的时候调用了一次 useState，此时的 stateHook 值是 initial，setState 通过闭包拿到的 state 也是 initial。</p><p>在下一次调用 setState、requestIdleCallback 开始工作、更新视图的时候，会再次执行当前的 FC 组件，在再次调用 useState，但是 state 的值还是 initial，因此视图无法更新。</p><p>如果想要视图更新，需要获取到当前 FC 的 fiber 在上一个时间片中的 state 值，据此更新视图</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initial</span>) &#123;<br>  <span class="hljs-comment">// 使用闭包暂时存储这个useState所在的FC的fiber</span><br>  <span class="hljs-keyword">let</span> currentFiber = wipFiber;<br>  <span class="hljs-comment">// 通过alternate指针将两个闭包里面的fiber联系起来。</span><br>  <span class="hljs-keyword">let</span> oldFiberHook = currentFiber.<span class="hljs-property">alternate</span>?.<span class="hljs-property">stateHook</span>;<br>  <span class="hljs-keyword">const</span> stateHook = &#123;<br>    <span class="hljs-attr">state</span>: oldFiberHook ? oldFiberHook.<span class="hljs-property">state</span> : initial,<br>  &#125;;<br>  currentFiber.<span class="hljs-property">stateHook</span> = stateHook;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">action</span>) &#123;<br>    <span class="hljs-comment">// 给wipRoot赋值，开启创建新fiber的流程</span><br>    stateHook.<span class="hljs-property">state</span> = <span class="hljs-title function_">action</span>(stateHook.<span class="hljs-property">state</span>);<br>    wipRoot = &#123;<br>      ...currentFiber,<br>      <span class="hljs-attr">alternate</span>: currentFiber,<br>    &#125;;<br>    nextWorkOfUnit = wipRoot;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [stateHook.<span class="hljs-property">state</span>, setState];<br>&#125;<br></code></pre></td></tr></table></figure><p>对于初始化阶段，当 work 执行到 FC 对应的 fiber 的时候，执行 fiber.type(fiber.props)，也就是自上而下地执行了这个 FC 对应的函数。useState 第一次被执行，此时所有 fiber 都没有 alternate，因此 oldFiberHook 为 undefined，stateHook 赋值的时候采用初始值，当前 FC 所对应的老的 fiber 添加了 stateHook 属性，此时的闭包（函数执行期上下文）记作 EC1，产生的 setState 引用的变量也是在 EC1 内</p><p>在某个时刻调用 setState 之后，EC1 闭包中的 state 值被更新，wipRoot 被赋值，workLoop 自动开始执行。当再次执行到这个 FC 时，通过 fiber.type(fiber.props)又运行了一次 useState，这个时候创建出来了 EC2，state 通过 alternate 被更新为 FC fiber 的 EC1 中的值，也就是刚刚触发的 action 的对 state 的更新结果，并将 EC2 中的 state 返回给 FC，FC 中 jsx 引用的 state 也更新为 EC2 中的值。</p><p>EC2 返回的 setState 函数等待下一次调用它的时刻，重复着修改 EC2 state -&gt; 重新构建 fiber 链表 -&gt; 处理 FC -&gt; fiber.type(fiber.props) -&gt; 执行 useState -&gt; 返回 EC3 的 set -&gt; … 循环往复</p><h3 id="一个-FC-存储多个-state"><a href="#一个-FC-存储多个-state" class="headerlink" title="一个 FC 存储多个 state"></a>一个 FC 存储多个 state</h3><p>如果只是用一个变量保存的话，前面的 state 会被后面的 state 覆盖，所以需要使用数组存储一个 FC 内的所有 state。由于一个应用里面有很多个 FC，每个 FC 有很多个 state，第一反应是直接在全局使用一个二维数组保存每个 n FC * m state，但是，每个 FC 想知道的仅仅是它自身在之前的 state，而不关心其他 FC，并且我们已经通过了上面的机制拿到了每个 FC 对应的闭包，所以使用庞大的二维表是完全没有必要的，应该在全局声明 stateHooks 和 stateHookIndex 两个变量，在每个 FC 对应的 fiber 闭包中初始化赋值为[]和 0</p><h3 id="批处理更新"><a href="#批处理更新" class="headerlink" title="批处理更新"></a>批处理更新</h3><p>上面的逻辑其实有一个很怪的点——setState 的时候，拿到了老 EC 闭包中的值，直接同步更新老的值，然后开始重新构建 DOM 树和 fiber 链表，再次进入 FC 函数，在第二次调用 FC 产生的闭包里面再次执行 useState 的时候，从老 EC 里面拿新值，这样非常不合理，为什么不能在新 EC 里面通过老 EC 的旧值算出新值呢，并且这样的同步修改方式在大量 setState 的时候，明明只需要最终更新一次视图，却因为中间产生了若干中间值而进行了多次不必要的更新。</p><p>解决方法：不同步更新，将所有 action 收集起来放到 updaterQueue 里面，在调用 setState 后再次进入 FC 的 useState 闭包时批量调用，调用完成之后才更新视图。视图只更新一次，提高更新效率</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><h3 id="实现基本的-init-之后调用-effect"><a href="#实现基本的-init-之后调用-effect" class="headerlink" title="实现基本的 init 之后调用 effect"></a>实现基本的 init 之后调用 effect</h3><p>useEffect 调用时机是 React 渲染真实 DOM 之后，并且浏览器完成重新绘制之前</p><p>和 useState 类似，给每个 wipFiber 挂载 effectHook，用以保存副作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useEffect</span>(<span class="hljs-params">callback, deps</span>) &#123;<br>  <span class="hljs-keyword">let</span> effectHook = &#123;<br>    callback,<br>    deps,<br>  &#125;;<br>  wipFiber.<span class="hljs-property">effectHook</span> = effectHook;<br>&#125;<br></code></pre></td></tr></table></figure><p>react 渲染完毕真实 DOM 的时机，即 commitRoot 统一提交中 commitWork 执行完毕的时候，递归遍历所有 fiber，调用绑定在它们身上的副作用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitRoot</span>(<span class="hljs-params"></span>) &#123;<br>  deletions.<span class="hljs-title function_">forEach</span>(commitDeletion);<br>  <span class="hljs-title function_">commitWork</span>(wipRoot.<span class="hljs-property">child</span>);<br>  <span class="hljs-comment">// 统一提交之后开启副作用</span><br>  <span class="hljs-title function_">commitEffect</span>();<br>  currentRoot = wipRoot;<br>  <span class="hljs-comment">// 重置当前活动的fiber</span><br>  wipRoot = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 重置需要删除的fiber</span><br>  deletions = [];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监听-deps，初始化和更新的时候执行副作用"><a href="#监听-deps，初始化和更新的时候执行副作用" class="headerlink" title="监听 deps，初始化和更新的时候执行副作用"></a>监听 deps，初始化和更新的时候执行副作用</h3><p>初始化的时候执行所有的 effect，更新的时候需要判断 deps 是否改变，再确定执行什么 effect，涉及到两个问题</p><ol><li>如何区分初始化和更新阶段：wipFiber.alternate 是否有值</li><li>更新阶段如何判断 deps 是否改变：some 比较新旧 deps 确定是否有依赖项变化，若变化则调用 callback</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitEffect</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">fiber</span>) &#123;<br>    <span class="hljs-comment">// 出口</span><br>    <span class="hljs-keyword">if</span> (!fiber) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据是否有alternate判断当前阶段是初始化还是update</span><br>    <span class="hljs-keyword">if</span> (!fiber.<span class="hljs-property">alternate</span>) &#123;<br>      <span class="hljs-comment">// init，直接执行所有的副作用</span><br>      fiber.<span class="hljs-property">effectHook</span>?.<span class="hljs-title function_">callback</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// update，deps发生变化的时候才执行副作用</span><br>      <span class="hljs-comment">// 有的fiber可能没有使用useEffect，没有effectHook属性，所以用可选链</span><br>      <span class="hljs-keyword">const</span> oldEffectHook = fiber.<span class="hljs-property">alternate</span>?.<span class="hljs-property">effectHook</span>;<br>      <span class="hljs-keyword">const</span> curEffectHook = fiber?.<span class="hljs-property">effectHook</span>;<br>      <span class="hljs-comment">// deps数组内的item只要有一项发生变化，则开启副作用</span><br>      <span class="hljs-keyword">const</span> needUpdate = oldEffectHook?.<span class="hljs-property">deps</span>.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">oldDep, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> oldDep !== curEffectHook?.<span class="hljs-property">deps</span>[index];<br>      &#125;);<br>      <span class="hljs-keyword">if</span> (needUpdate) &#123;<br>        curEffectHook.<span class="hljs-title function_">callback</span>();<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">run</span>(fiber.<span class="hljs-property">child</span>);<br>    <span class="hljs-title function_">run</span>(fiber.<span class="hljs-property">sibling</span>);<br>  &#125;<br>  <span class="hljs-title function_">run</span>(wipFiber);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多个副作用"><a href="#多个副作用" class="headerlink" title="多个副作用"></a>多个副作用</h3><p>和 useState 的处理方式相同，也需要在全局定义一个收集所有 effect 的变量 effectHooks。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> effectHooks;<br></code></pre></td></tr></table></figure><p>在进入 FC 的时候 effectHooks 初始化为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 处理函数组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleFunctionComponent</span>(<span class="hljs-params">fiber</span>) &#123;<br>  <span class="hljs-comment">// 存储将来要更新的FC fiber</span><br>  wipFiber = fiber;<br>  <span class="hljs-comment">// 初始化当前fiber在当前闭包中的stateHooks和对应的index</span><br>  stateHookIndex = <span class="hljs-number">0</span>;<br>  stateHooks = [];<br>  <span class="hljs-comment">// 初始化副作用</span><br>  effectHooks = [];<br>  <span class="hljs-keyword">const</span> children = [fiber.<span class="hljs-title function_">type</span>(fiber.<span class="hljs-property">props</span>)];<br>  <span class="hljs-title function_">reconcileChildren</span>(fiber, children);<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用 useEffect 的时候把所有的 callback 和 deps 收集到 wipFiber.effectHooks 里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useEffect</span>(<span class="hljs-params">callback, deps</span>) &#123;<br>  <span class="hljs-keyword">let</span> effectHook = &#123;<br>    callback,<br>    deps,<br>  &#125;;<br>  effectHooks.<span class="hljs-title function_">push</span>(effectHook);<br>  wipFiber.<span class="hljs-property">effectHooks</span> = effectHooks;<br>&#125;<br></code></pre></td></tr></table></figure><p>在统一处理 effectHooks 的时候分情况（init update）遍历处理所有的 effectHook。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 根据是否有alternate判断当前阶段是初始化还是update</span><br><span class="hljs-keyword">if</span> (!fiber.<span class="hljs-property">alternate</span>) &#123;<br>  <span class="hljs-comment">// init，直接执行所有的副作用</span><br>  fiber.<span class="hljs-property">effectHooks</span>?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effectHook</span>) =&gt;</span> &#123;<br>    effectHook?.<span class="hljs-title function_">callback</span>();<br>  &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// update，deps发生变化的时候才执行副作用</span><br>  fiber.<span class="hljs-property">effectHooks</span>?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">hook, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 有的fiber可能没有使用useEffect，没有effectHook属性，所以用可选链</span><br>    <span class="hljs-keyword">const</span> oldEffectHook = fiber.<span class="hljs-property">alternate</span>?.<span class="hljs-property">effectHooks</span>[index];<br>    <span class="hljs-keyword">const</span> curEffectHook = hook;<br>    <span class="hljs-comment">// deps数组内的item只要有一项发生变化，则开启副作用</span><br>    <span class="hljs-keyword">const</span> needUpdate = oldEffectHook?.<span class="hljs-property">deps</span>.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">oldDep, i</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> oldDep !== curEffectHook?.<span class="hljs-property">deps</span>[i];<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (needUpdate) &#123;<br>      curEffectHook.<span class="hljs-title function_">callback</span>();<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h3><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>一个 FC fiber 应该使用数组存储内含的多个 useEffect item，而一个 useEffect item 应该存储其 callback deps 和 cleanup</p><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>effect 的调用结果</p><h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><p>在组件更新、创建完新的之后会先调用上一次调用 effect 产生的旧的 cleanup（minireact 限制，不调用 deps 为空的 cleanup），再调用 effect 产生新的 cleanup 供下次调用</p><h1 id="习得的神技"><a href="#习得的神技" class="headerlink" title="习得的神技"></a>习得的神技</h1><h2 id="画图-debugger-事半功倍"><a href="#画图-debugger-事半功倍" class="headerlink" title="画图+debugger 事半功倍"></a>画图+debugger 事半功倍</h2><p>以往遇到 bug 的时候，我通常采用的方式是直接打断点调试，这是通解也是最慢的解法，但是往往可以发现一些让人捶胸顿足、哭笑不得的非算法错误。</p><p>如果有十足的把握判断 bug 出现的原因和当前的数据结构与算法有关，不妨在调试之前先画图梳理一遍逻辑。</p><p>比如在返回下一个 fiber 的时候，仅仅按照起初的 child -&gt; sibling -uncle 策略在 dom 树层级较深的时候会在某一棵子树末尾报错，画图在脑海中模拟一遍很快就能发现原因——子树层级太深且向上的很多层 parent.sibling 都为空。一旦锁定真正的问题根因，再难的问题也迎刃而解。</p><p><img src="/img/react/mini-react/parent-find-process.png" alt="Alt text"></p><h2 id="迁移扩展知识，“以不变应万变”"><a href="#迁移扩展知识，“以不变应万变”" class="headerlink" title="迁移扩展知识，“以不变应万变”"></a>迁移扩展知识，“以不变应万变”</h2><p>知识和解决问题的思路是可以迁移扩展的，我们在学习的过程中需要刻意头脑风暴，设想一些当前处理的问题还可能发生的场景，或者当前的方案还可以迁移到哪里。</p><p>比如我在该系列课程中最重要的收获有两点：</p><ol><li>非线形的 DOM 树的渲染任务拆分成单个 fiber 构成的线性链表、利用浏览器空余时间执行微任务</li><li>在整个任务执行过程中，利用闭包缓存每个 FC 的 fiber，useState、useEffect 均使用到了该技巧</li></ol><p>迁移扩展：</p><ol><li>DOM 树的渲染和 svg 图元的渲染别无二致，都可以使用这种微任务思想来解决。更推广的场景是对于运行在浏览器上的 CPU 计算密集型任务，都可以拆分任务，利用浏览器空闲时间逐个击破</li><li>任务执行期的闭包缓存相当于在该阶段打断点，如果运行过程中某些变量的中间值是我们在运行结束后仍然需要的，就可以使用闭包方式把这些值“紧握不放”，有需要的时候再随用随取</li></ol><h2 id="开发三驾马车之一——按图索骥实现基础功能"><a href="#开发三驾马车之一——按图索骥实现基础功能" class="headerlink" title="开发三驾马车之一——按图索骥实现基础功能"></a>开发三驾马车之一——按图索骥实现基础功能</h2><p>开发时通常涉及到三个问题：基础的功能需求实现、函数设计和重构。如果这三驾马车并驾齐驱，无疑会把简单的问题复杂化。我们应该将这三件任务拆分然后逐一执行，减小任务的复杂度。</p><p>面对一个新需求，首先思考的仅仅是如何在现有基础上实现最基本的功能，其余的变量命名风格、逻辑抽象封装等可以先不考虑，甚至可以先实现一种最容易想到的情况。比如在实现 children 更新的时候，移除旧的 fiber 对应的 DOM，最简单直接的思路就是让当前的<code>fiber.parent.dom</code>删除<code>fiber.dom</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 基础功能</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitDeletion</span>(<span class="hljs-params">fiber</span>) &#123;<br>  parentFiber.<span class="hljs-property">dom</span>.<span class="hljs-title function_">removeChild</span>(fiber.<span class="hljs-property">dom</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="开发三驾马车之二——普适函数的进阶设计"><a href="#开发三驾马车之二——普适函数的进阶设计" class="headerlink" title="开发三驾马车之二——普适函数的进阶设计"></a>开发三驾马车之二——普适函数的进阶设计</h2><p>在基本功能实现的基础上，我们深入思考往往会发现，基本功能往往会和其他的功能产生联系。</p><p>比如上面实现的 children 更新，考虑到<strong>function component fiber 没有 dom</strong>的特性，在设计通用功能的时候还需要解决两个问题：</p><ol><li>在 fiber 为 FC fiber 时，<code>fiber.dom</code>为空</li><li>在 fiber.parent 为 FC fiber 时，<code>fiber.parent.dom</code>为空</li></ol><p>因此，第一步的普通实现应该以解决这两个问题为目标，进一步迭代设计：</p><ol><li><code>fiber.dom</code>不为空时才执行删除</li><li><code>fiber.parent.dom</code>为空时一直向上寻找有 dom 的祖先</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 进阶设计</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitDeletion</span>(<span class="hljs-params">fiber</span>) &#123;<br>  <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">dom</span>) &#123;<br>    <span class="hljs-comment">// 如果当前fiber是FC child，父fiber没有dom，就一直向上找</span><br>    <span class="hljs-keyword">let</span> parentFiber = fiber.<span class="hljs-property">parent</span>;<br>    <span class="hljs-keyword">while</span> (!parentFiber.<span class="hljs-property">dom</span>) &#123;<br>      parentFiber = parentFiber.<span class="hljs-property">parent</span>;<br>    &#125;<br>    parentFiber.<span class="hljs-property">dom</span>.<span class="hljs-title function_">removeChild</span>(fiber.<span class="hljs-property">dom</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果当前fiber没有dom，说明是FC，删除它的child即可</span><br>    <span class="hljs-title function_">commitDeletion</span>(fiber.<span class="hljs-property">child</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更普适的情况是，前后 fiber 链表不等长，因此进阶设计又可以进一步进阶，直到可以 cover 我们认为的普适场景</p><h2 id="开发三驾马车之三——贯穿开发周期的重构"><a href="#开发三驾马车之三——贯穿开发周期的重构" class="headerlink" title="开发三驾马车之三——贯穿开发周期的重构"></a>开发三驾马车之三——贯穿开发周期的重构</h2><p>重构主要包括以下几个部分：</p><ol><li>变量、函数的重命名；</li><li>代码段的抽象封装，凡是可以用一句明确的话总结的某一段功能代码，都可以抽离封装成一个函数；</li><li>梳理代码执行过程，调整函数的执行位置；</li><li>思考普适场景中 corner case 的解决方法。</li></ol><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>和群里的小伙伴一起一周通关 mini-react 是一件很有意义的事情，自高中毕业以来很少再有这种集体监督打卡任务的机会了。对于我自身而言，打卡和问题讨论的意义并不是其本身（自认为自制力和独立求知欲还可以），而是一群人为了一个目标踏实奋斗的氛围可以让我更有动力，每天的“肉眼可见“的总结思考可以让我真切体会到自己的进步。</p><p>群里有一些大佬的水平非常高，我这么个前端小白的水平实在是相形见绌，但是也不能产生太严重的焦虑情绪，要相信自己未来可期，希望可以快点实习早日毕业，在实际工作中历练自己，期待能“望其项背”的一天。</p><p>谨以此文，总结我一周来的学习成果和心路历程，与诸君共勉。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>mini-react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useState</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useImperativeHandle</title>
    <link href="/2023/06/21/useImperativeHandle/"/>
    <url>/2023/06/21/useImperativeHandle/</url>
    
    <content type="html"><![CDATA[<h3 id="useImperativeHandle-和-ref-转发"><a href="#useImperativeHandle-和-ref-转发" class="headerlink" title="useImperativeHandle 和 ref 转发"></a>useImperativeHandle 和 ref 转发</h3><p><strong>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值，应当与 forwardRef 一起使用，实现 ref 转发</strong></p><p><strong>我们获取类组件实例后，可以直接调用实例上的方法！</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  submit = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了子组件的submit方法！&quot;</span>);<br>  &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>           ...        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> box = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">current</span>); <span class="hljs-comment">//子组件的实例</span><br>    box.<span class="hljs-property">current</span>.<span class="hljs-title function_">submit</span>();<br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box&#125;</span> /&gt;</span>   </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是直接把 ref 赋值给函数组件，是不被允许的！</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>       ...    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> box = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">current</span>); <span class="hljs-comment">//null // Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</span><br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box&#125;</span> /&gt;</span>   </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>此时我们可以基于 forwardRef 和 useImperativeHandle , 就可以实现父组件调用子组件中的方法！</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;<br>  useEffect,<br>  useRef,<br>  useImperativeHandle,<br>  forwardRef,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">props, ref</span>) &#123;<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">submit</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了子组件的submit方法！&quot;</span>);<br>      &#125;,<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>       ...    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> box = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">current</span>);<br>    box.<span class="hljs-property">current</span>.<span class="hljs-title function_">submit</span>();<br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box&#125;</span> /&gt;</span>   </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useImperativeHandle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useRef深层剖析</title>
    <link href="/2023/06/19/useRef/"/>
    <url>/2023/06/19/useRef/</url>
    
    <content type="html"><![CDATA[<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><h4 id="ref-使用场景"><a href="#ref-使用场景" class="headerlink" title="ref 使用场景"></a>ref 使用场景</h4><p><strong>通常，当你的组件需要“跳出” React 并与外部 API 通信时，你会用到 ref —— 通常是不会影响组件外观的浏览器 API。以下是这些罕见情况中的几个：</strong></p><ul><li><strong>存储 <a href="https://developer.mozilla.org/docs/Web/API/setTimeout">timeout ID</a></strong></li><li><strong>存储和操作 <a href="https://developer.mozilla.org/docs/Web/API/Element">DOM 元素</a>，涉及非受控组件。赋值给标签，目的是获取 DOM 元素；赋值给类组件，目的是获取组件的实例；</strong></li><li><strong>存储不需要被用来计算 JSX 的其他对象。</strong></li></ul><p><strong>如果你的组件需要存储一些值，但不影响渲染逻辑，请选择 ref。</strong></p><h4 id="类组件的三种创建和使用方式"><a href="#类组件的三种创建和使用方式" class="headerlink" title="类组件的三种创建和使用方式"></a>类组件的三种创建和使用方式</h4><h5 id="方式一——字符串形式的-ref（过时了，未来版本可能移除，开发时不推荐使用，效率低）"><a href="#方式一——字符串形式的-ref（过时了，未来版本可能移除，开发时不推荐使用，效率低）" class="headerlink" title="方式一——字符串形式的 ref（过时了，未来版本可能移除，开发时不推荐使用，效率低）"></a>方式一——字符串形式的 ref（<strong>过时了，未来版本可能移除，开发时不推荐使用，效率低</strong>）</h5><p><strong>通过 <code>this.refs</code>访问</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">ref</span>=&quot;input1&quot;/&gt;<br></code></pre></td></tr></table></figure><h5 id="方式二——回调形式的-ref"><a href="#方式二——回调形式的-ref" class="headerlink" title="方式二——回调形式的 ref"></a>方式二——回调形式的 ref</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">React帮我们调用回调函数，并且将当前的DOM节点传入回调函数<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;input<br>  ref=&#123;<span class="hljs-function">(<span class="hljs-params">currentNode</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = currentNode;<br>  &#125;&#125;<br>/&gt;<br><span class="hljs-comment">// currentNode是当前所处的节点，也就是这个input</span><br></code></pre></td></tr></table></figure><p><strong>不能通过 <code>this.refs</code>访问，因为这些 ref 都成了实例属性</strong></p><p><strong>React 不会帮你执行未知属性的回调函数</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;input<br>  ref=&#123;<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = c)&#125;<br>  ahh=&#123;<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  &#125;&#125;<br>  type=<span class="hljs-string">&quot;text&quot;</span><br>  placeholder=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span><br>/&gt;<br></code></pre></td></tr></table></figure><p><strong>如果 ref 回调函数是以**<strong>内联函数的形式定义的，在更新过程中它会被执行两次</strong>，第一次传入参数 null，第二次传入参数 DOM 元素。这是因为在每次渲染时创建一个新的实例，所以 React 清空旧的 ref 并设置新的。通过</strong>将 ref 的回调函数定义成 class 的绑定函数<strong>的方式可以避免上述问题，但是</strong>大多数情况下它是无效的（无关紧要）**</p><h5 id="方式三——createRef-创建-ref-容器（最推荐）"><a href="#方式三——createRef-创建-ref-容器（最推荐）" class="headerlink" title="方式三——createRef 创建 ref 容器（最推荐）"></a>方式三——createRef 创建 ref 容器（<strong>最推荐</strong>）</h5><p><em>React.createRef 调用后可以返回一个容器，该容器可以存储被 ref 所标识的节点,该容器是“专人专用”的，多个 ref 的值可以相互独立</em></p><p><strong>ref 是实例的属性，不能通过 this.refs 访问</strong></p><p><strong>this.myRef.current 是当前引用的 DOM，this.myRef.current.value 是当前 DOM 的值</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">myRef</span> <span class="hljs-operator">=</span> React.createRef()<span class="hljs-comment">;</span><br>&lt;input ref<span class="hljs-operator">=</span>&#123;this.myRef&#125; /&gt;<br></code></pre></td></tr></table></figure><h4 id="hooks-组件通过-useRef-创建-ref-对象"><a href="#hooks-组件通过-useRef-创建-ref-对象" class="headerlink" title="hooks 组件通过 useRef 创建 ref 对象"></a>hooks 组件通过 useRef 创建 ref 对象</h4><p><strong>在函数组件中，可以基于</strong> <code>useRef</code>获取 DOM 元素！类似于类组件中的 ：</p><ul><li><strong>ref&#x3D;{x&#x3D;&gt;thix.box&#x3D;x}</strong></li><li><strong>React.createRef</strong></li></ul><p><strong>函数组件中创建 ref 对象的两种方法：</strong></p><ul><li><code>let box1 = useRef(null)</code></li><li><code>let box2 = React.createRef();</code></li></ul><p><strong>注意：</strong></p><p><strong>React.createRef 也是 ref 对象，在类组件和函数组件中都可以使用</strong></p><p><strong>useRef 只能在函数组件中使用，所有的 hooks 函数都只能在函数组件中使用，在类组件中使用会报错</strong></p><p><strong>ref 只能在 DOM 创建之后才能获取 DOM 元素，也就是说在 useLayoutEffect 阶段就可以使用</strong></p><h4 id="createRef-性能比-useRef-差——每次渲染创建新-ref-对象"><a href="#createRef-性能比-useRef-差——每次渲染创建新-ref-对象" class="headerlink" title="createRef 性能比 useRef 差——每次渲染创建新 ref 对象"></a>createRef 性能比 useRef 差——每次渲染创建新 ref 对象</h4><ul><li><strong>createRef 每次渲染都会返回一个新的引用</strong></li><li><strong>而 useRef 每次都会返回相同的引用</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./Demo.less&#x27;</span>;<br><br><span class="hljs-keyword">let</span> prev1,<br>    prev2;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 函数组件中创建ref对象的两种方法</span><br>    <span class="hljs-keyword">let</span> box1 = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>),<br>        box2 = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>    <span class="hljs-keyword">if</span> (!prev1) &#123;<br>        <span class="hljs-comment">// 第一次DEMO执行，把第一次创建的REF对象赋值给变量</span><br>        prev1 = box1;<br>        prev2 = box2;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 第二次DEMO执行，我们验证一下，新创建的REF对象，和之前第一次创建的REF对象，是否一致？</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prev1 === box1); <span class="hljs-comment">//true  useRef再每一次组件更新的时候（函数重新执行），再次执行useRef方法的时候，不会创建新的REF对象了，获取到的还是第一次创建的那个REF对象！！</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prev2 === box2); <span class="hljs-comment">//false createRef在每一次组件更新的时候，都会创建一个全新的REF对象出来，比较浪费性能！！</span><br>        <span class="hljs-comment">// 总结：在类组件中，创建REF对象，我们基于 React.createRef 处理；但是在函数组件中，为了保证性能，我们应该使用专属的 useRef 处理！！</span><br>    &#125;<br><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box1.<span class="hljs-property">current</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box2.<span class="hljs-property">current</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box1&#125;</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box2&#125;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">                setNum(num + 1);</span><br><span class="language-xml">            &#125;&#125;&gt;</span><br><span class="language-xml">            新增</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>总结：在类组件中，创建 Ref 对象，基于 React.createRef 处理；在函数组件中为了保证性能使用 useRef</strong></p><h4 id="ref-的-DOM-用法总结【useRef】"><a href="#ref-的-DOM-用法总结【useRef】" class="headerlink" title="ref 的 DOM 用法总结【useRef】"></a>ref 的 DOM 用法总结【useRef】</h4><ul><li><strong>给元素标签设置 ref，目的：获取对应的 DOM 元素</strong></li><li><strong>给类组件设置 ref，目的：获取当前调用组件创建的实例（后续可以根据实例获取子组件中的相关信息）</strong><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 基于ref获取子组件的实例，这样基于实例，可以调用子组件内部，挂载到实例上的东西</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    state = &#123; x: <span class="hljs-number">1000</span> &#125;;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> &lt;div className=<span class="hljs-string">&quot;child-box&quot;</span>&gt;<br>            &#123;<span class="hljs-keyword">this</span>.state.x&#125;<br>        &lt;/div&gt;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>给函数组件&#x2F;hooks 设置 ref，直接报错：Function components cannot be given refs. Attempts to access this ref wil fail，但是可以配合 React.forwardRef 实现 ref 的转发。目的：获取函数子组件内的某个 DOM 元素</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 基于forwardRef实现ref转发，目的：获取子组件内部的某个元素</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">props, ref</span>) &#123;<br>    <span class="hljs-comment">// console.log(ref); //在DEMO中，调用Child的时候，传递的ref对象「x」</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;child-box&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useRef</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useLayoutEffect深层剖析</title>
    <link href="/2023/06/17/useLayoutEffect/"/>
    <url>/2023/06/17/useLayoutEffect/</url>
    
    <content type="html"><![CDATA[<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>useLayoutEffect 函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后<strong>同步</strong>调用 effect。</p><p>可以使用它来读取 DOM 布局并同步触发重渲染。</p><p>在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p><p>尽可能使用标准的 useLayoutEffect 以避免阻塞视觉更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect, useLayoutEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 再试试useLayoutEffect</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">let</span> random = +<span class="hljs-title class_">String</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()).<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-title function_">setNum</span>(random);<br>    &#125;<br>  &#125;, [num]);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">background:</span> &#x27;<span class="hljs-attr">lightblue</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">WebkitUserSelect:</span> &#x27;<span class="hljs-attr">none</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">      &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setNum(0);</span><br><span class="language-xml">      &#125;&#125;</span><br><span class="language-xml">    &gt;</span><br><span class="language-xml">      &#123;num&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useEffect-和-useLayoutEffect-区别"><a href="#useEffect-和-useLayoutEffect-区别" class="headerlink" title="useEffect 和 useLayoutEffect 区别"></a>useEffect 和 useLayoutEffect 区别</h3><p><strong>useLayoutEffect 会阻塞浏览器渲染真实 DOM【真实 DOM 对象已经创建了】，优先执行 Effect 链表中的 callback；</strong></p><p><strong>useEffect 不会阻塞浏览器渲染真实 DOM，在渲染真实 DOM 的同时，去执行 Effect 链表中的 callback</strong></p><ul><li>它们里面的回调函数<strong>都是放在 effect 链表</strong>中的，但是 useLayoutEffect 设置的 callback 要<strong>优先</strong>于 useEffect 去执行</li><li>在两者设置的 callback 中，<strong>依然可以获取 DOM 元素</strong>「原因：真实 DOM 对象已经创建了，区别只是浏览器是否渲染」</li><li>如果在 callback 函数中又修改了状态值「视图又要更新」<ul><li>useEffect:浏览器肯定是把第一次的真实已经绘制了，再去渲染第二次真实 DOM【频繁切换有闪烁】</li><li>useLayoutEffect:浏览器是把两次真实 DOM 的渲染，<strong>合并在一起渲染</strong>的【频繁切换无闪烁】</li></ul></li></ul><h3 id="视图更新周期："><a href="#视图更新周期：" class="headerlink" title="视图更新周期："></a>视图更新周期：</h3><p><strong>第一步：基于 babel-preset-react-app 把 JSX 编译为 createElement 格式</strong></p><p><strong>第二步：执行 createElement(…)方法，创建出 virtualDOM</strong></p><p><strong>第三步：基于 root.render 方法把 virtualDOM 变为真实 DOM 对象「DOM-DIFF」</strong></p><p><strong>useLayoutEffect 阻塞浏览器绘制：在整个视图渲染更新周期中，创建出真实 DOM 以后直接执行 useLayoutEffect 的 effect 链表中的方法。如果该方法有 setXXX 操作，那么会直接进入下一次更新周期中，而不会执行第四步。因此无论视图更新的过程执行了多少次，界面永远只看到了一次变化，即【频繁切换无闪烁】</strong></p><p><strong>useEffect 不阻塞浏览器绘制：在 React 渲染完真实 DOM 之后、浏览器绘制完毕之前会执行 effect 链表中的方法，同时第四步也会异步执行。如果 effect 链表中的方法有 setXXX 操作，那么会直接进入下一次更新周期中，同时上一次更新周期中的第四步还在执行，浏览器还在重绘。如果在 useEffect 中频繁触发更新，后台会异步运行多个“第四步”，由于浏览器绘制是需要一定时间的，因此对于速度较慢的设备，用户会看到多次重绘之间的“白屏”，即【频繁切换有闪烁】</strong></p><p><strong>第四步：浏览器渲染和绘制真实 DOM 对象</strong></p><p><strong>从视图更新周期可以看出，useLayoutEffect 和 useEffect 都是可以获取真实 DOM 的时机</strong></p><h3 id="官方文档示例参考"><a href="#官方文档示例参考" class="headerlink" title="官方文档示例参考"></a>官方文档示例参考</h3><p><a href="https://react.docschina.org/reference/react/useLayoutEffect#usage">https://react.docschina.org/reference/react/useLayoutEffect#usage</a></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useLayoutEffect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useState深层剖析</title>
    <link href="/2023/06/14/useState/"/>
    <url>/2023/06/14/useState/</url>
    
    <content type="html"><![CDATA[<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>作用：在函数组件中使用状态，修改状态值可让函数组件更新，类似于类组件中的 setState</p><p>语法：</p><p>const [state, setState] &#x3D; useState(initialState);</p><p>返回一个 state，以及更新 state 的函数</p><p>seXXX(value)修改状态值为 value，并通知视图更新。注意，不同于类组件 setState 的部分更新语法，而是直接修改成 value</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setNum</span>(num + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>新增<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>函数组件【Hooks 组件】不是类组件，所以没有实例的概念，调用组件不再是创建类的实例，而是执行函数并产生一个私有上下文而已，所以在函数组件中不涉及 this 的处理</p><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a><strong>设计原理</strong></h3><p><strong>类组件只在初次渲染时创建一个实例，之后的更新都是按照生命流程走，并不是重新创造实例。</strong></p><p><strong>函数组件的每一次渲染或更新是让函数重新执行，也就是 useState 会被重新执行，产生一个全新的私有上下文，内部的代码也重新执行</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数组件每一次渲染/更新，都具备独立的闭包</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">//10</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>新增<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li><p><strong>执行 handle 方法时，由于所用到的 setNum num 都不是当前作用域的私有变量，所以里面会沿着作用域链找到上级上下文里面的 num 和 setNum（闭包）</strong></p></li><li><p><strong>每次更新都重新执行一次内部的代码、都创建一个新的私有上下文如 EC(DEMO2)，涉及的函数需要进行重新构建。这些函数的作用域会沿着函数的作用域链向上查找，找到每一次执行 DEMO 产生的新的闭包</strong></p></li><li><p><strong>每一次执行 DEMO 函数，也会把 useState 重新执行。但是：</strong></p><ul><li><strong>返回的状态：只有第一次设置的初始值会生效，其余以后再执行，获取的状态都是最新的状态，而不是初始值。</strong></li><li><strong>返回的修改状态的方法：每一次都是新的方法函数</strong></li><li><strong>每次运行 useState 返回的结果都用新的 num 和 setNum 变量保存，因此状态和修改状态的方法的地址和之前的都不同，是全新的</strong></li></ul></li></ol><p><img src="/img/react/useState/useState%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.jpg"></p><p>那么它是如何确保每一次获取的是最新状态值，而不是传递的初始值呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 核心原理：闭包</span><br><span class="hljs-keyword">var</span> _state; <span class="hljs-comment">// 创建全局state。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  _state = _state | initialState;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(_state, value)) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>  _state = <span class="hljs-title function_">value</span>(_state) <span class="hljs-comment">// 相当于传入prevalue后，return经过处理得到的新value</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  _state = value<br>  &#125;<br>    <span class="hljs-comment">// 通知视图更新</span><br>    <span class="hljs-comment">//...重新渲染组件</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> [_state, setState]; <span class="hljs-comment">// 数组是新的变量，里面的每项自然也是新的，栈地址也不相同</span><br>&#125;<br><br><span class="hljs-keyword">let</span> [num1, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始时num1=0  setNum=setState 0x001</span><br><span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//=&gt;_state=100 通知视图更新</span><br><span class="hljs-comment">// ---</span><br>再次执行整个函数组件，在执行到useState的时候：<br><span class="hljs-keyword">let</span> [num2, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//由于初次渲染时，全局state被赋值了，不再为undefined，所以不再赋值为initialState</span><br>在内部又产生了一个新的setState，地址和之前不同，使用这次新的闭包作为父级上下文<br>最后返回新的state和新的setState并被声明为新的变量<br>num2=<span class="hljs-number">100</span>  setNum=setState <span class="hljs-number">0x002</span><br></code></pre></td></tr></table></figure><h3 id="setXXX-沿着作用域查找闭包的理解——与同步异步无关"><a href="#setXXX-沿着作用域查找闭包的理解——与同步异步无关" class="headerlink" title="setXXX 沿着作用域查找闭包的理解——与同步异步无关"></a>setXXX 沿着作用域查找闭包的理解——与同步异步无关</h3><p><img src="/img/react/useState/2.png"></p><p><strong>第一个 setTimeout 沿着作用域链找到的闭包里的 num 是初始渲染的 num，和 setNum 后产生的新的闭包（作用域）无关，因此输出 0</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 0</span><br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span>;<br></code></pre></td></tr></table></figure><h3 id="更新多状态"><a href="#更新多状态" class="headerlink" title="更新多状态"></a>更新多状态</h3><h4 id="方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX-不支持类组件-setState-的-partial-state-change"><a href="#方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX-不支持类组件-setState-的-partial-state-change" class="headerlink" title="方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX 不支持类组件 setState 的 partial state change"></a>方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX 不支持类组件 setState 的 partial state change</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-number">20</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// setState(&#123; x: 100 &#125;); //state=&#123;x:100&#125;</span><br>    <span class="hljs-title function_">setState</span>(&#123;<br>      ...state,<br>      <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>    &#125;);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;state.x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;state.y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：不能像类组件的 setState 函数一样，支持部分状态更新！</p><h4 id="方案二：执行多次-useState，把不同状态分开进行管理「推荐方案」——解耦"><a href="#方案二：执行多次-useState，把不同状态分开进行管理「推荐方案」——解耦" class="headerlink" title="方案二：执行多次 useState，把不同状态分开进行管理「推荐方案」——解耦"></a>方案二：执行多次 useState，把不同状态分开进行管理「推荐方案」——解耦</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>),<br>    [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(<span class="hljs-number">100</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新队列机制【updater，异步批处理】——异步和闭包是两码事"><a href="#更新队列机制【updater，异步批处理】——异步和闭包是两码事" class="headerlink" title="更新队列机制【updater，异步批处理】——异步和闭包是两码事"></a>更新队列机制【updater，异步批处理】——异步和闭包是两码事</h3><p>和类组件中的 setState 一样，每次更新状态值，也不是立即更新，而是利用了更新队列 updater 机制来处理</p><p>① 遇到 setState 会立即将其放入到<strong>更新队列</strong>中，此时状态和视图还都未更新</p><p>②<strong>当所有的代码操作结束</strong>，会刷新队列，也就是通知更新队列中的所有任务执行：把<strong>所有放入的 setState 合并在一起执行，只触发一次状态更新和视图更新</strong></p><ul><li><strong>React 18 全部采用批更新</strong></li><li><strong>React 16 中也和 this.setState 一样，只在合成事件&#x2F;生命周期函数中异步，在定时器、手动 DOM 事件绑定等操作中同步</strong></li><li><strong>可以基于 flushSync 刷新渲染队列</strong></li></ul><p><img src="/%60/img/react/useState/image-20230616122123869.png%60" alt="img"></p><h4 id="检验方式一-在-handler-里面修改-state-之后直接-log-❌"><a href="#检验方式一-在-handler-里面修改-state-之后直接-log-❌" class="headerlink" title="检验方式一:在 handler 里面修改 state 之后直接 log ❌"></a>检验方式一:在 handler 里面修改 state 之后直接 log ❌</h4><p><strong>不能在 handler 里面修改 state 之后直接 log，因为这时 log 的变量仍然是上一次闭包中的，无论同步还是异步更新，都只能是上一个闭包中的值</strong></p><p><strong>因此，每次 log 的结果都是上一次的 state</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Demo.less&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>),<br>    [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>),<br>    [z, setZ] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">30</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(x + <span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>    <span class="hljs-comment">// 1.异步批处理：所有的setXXX操作放到更新队列里面，执行完所有操作之后才会一次清空更新队列，因此console.log先执行</span><br>    <span class="hljs-comment">// 2.闭包：由于handle始终拿到的是父级作用域的闭包，也就是更新前的闭包</span><br>    <span class="hljs-title function_">setY</span>(y + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setZ</span>(z + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>y:&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>z:&#123;z&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span>;<br></code></pre></td></tr></table></figure><h4 id="检验方式二：比较输出”验证值的次数“"><a href="#检验方式二：比较输出”验证值的次数“" class="headerlink" title="检验方式二：比较输出”验证值的次数“"></a>检验方式二：比较输出”验证值的次数“</h4><p>若同步更新，那么会顺序输出“render”三次</p><p>若异步更新，则只在最后批处理更新一次，所以只输出一次</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Demo.less&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;RENDER渲染&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>),<br>    [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>),<br>    [z, setZ] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">30</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(x + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setY</span>(y + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setZ</span>(z + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>y:&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>z:&#123;z&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span>;<br></code></pre></td></tr></table></figure><p><strong>只更新了一次，说明是异步执行的，与位置无关</strong></p><p><img src="/img/react/useState/3.png"></p><h4 id="更新队列-flushSync-设置同步操作"><a href="#更新队列-flushSync-设置同步操作" class="headerlink" title="更新队列 flushSync 设置同步操作"></a>更新队列 flushSync 设置同步操作</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">let</span> [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">/* setX(100);</span><br><span class="hljs-comment">        setY(200); */</span><br><br>    <span class="hljs-comment">/* setTimeout(() =&gt; &#123;</span><br><span class="hljs-comment">            setX(100);</span><br><span class="hljs-comment">            setY(200);</span><br><span class="hljs-comment">        &#125;, 1000); */</span><br><br>    <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setX</span>(<span class="hljs-number">100</span>);<br>    &#125;);<br>    <span class="hljs-title function_">setY</span>(<span class="hljs-number">200</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/react/useState/4.png"></p><h4 id="通过-setXXX-传入-prev-跳出闭包"><a href="#通过-setXXX-传入-prev-跳出闭包" class="headerlink" title="通过 setXXX 传入(prev) &#x3D;&gt;跳出闭包"></a>通过 setXXX 传入(prev) &#x3D;&gt;跳出闭包</h4><h4 id="异步操作与闭包函数作用域例题"><a href="#异步操作与闭包函数作用域例题" class="headerlink" title="异步操作与闭包函数作用域例题"></a>异步操作与闭包函数作用域例题</h4><p><img src="/img/react/useState/5.png"></p><p>异步：handle 里面的 10 次 setX 都会放在更新队列里面，然后在其他事情都做完之后，批处理一次更新完毕所有队列中的数据和视图，因此只’RENDER 渲染’一次</p><p>闭包：x 最后的状态值是 11，因为 handle 里面的所有 x 都是在上一级闭包中拿到的，都是 10，因此批处理中 10 个 setX 都是将 x 更新为 11</p><h3 id="setXXX-的两种传参方式"><a href="#setXXX-的两种传参方式" class="headerlink" title="setXXX 的两种传参方式"></a>setXXX 的两种传参方式</h3><h4 id="1-直接传入新对象，不支持-this-setState-的部分更新"><a href="#1-直接传入新对象，不支持-this-setState-的部分更新" class="headerlink" title="1.直接传入新对象，不支持 this.setState 的部分更新"></a>1.直接传入新对象，不支持 this.setState 的部分更新</h4><h4 id="2-函数式更新——配合-for-循环、updater-机制可以实现结果累计、只更新状态和视图一次-setXXX-prev-，可以有效解决-updater-的闭包问题"><a href="#2-函数式更新——配合-for-循环、updater-机制可以实现结果累计、只更新状态和视图一次-setXXX-prev-，可以有效解决-updater-的闭包问题" class="headerlink" title="2.函数式更新——配合 for 循环、updater 机制可以实现结果累计、只更新状态和视图一次 setXXX(prev &#x3D;&gt;)，可以有效解决 updater 的闭包问题"></a>2.函数式更新——配合 for 循环、updater 机制可以实现结果累计、只更新状态和视图一次 setXXX(prev &#x3D;&gt;)，可以有效解决 updater 的闭包问题</h4><p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState；该函数将接收先前的 state，并返回一个更新后的值！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>      <span class="hljs-comment">// 函数式更新</span><br>      <span class="hljs-title function_">setNum</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span>;<br>      &#125;);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 核心原理：闭包</span><br><span class="hljs-keyword">var</span> _state; <span class="hljs-comment">// 创建全局state。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  _state = _state | initialState;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> _state === <span class="hljs-string">&#x27;undefined&#x27;</span>)&#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> initialState === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>          _state = <span class="hljs-title function_">initialState</span>();<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          _state = initialState;<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(_state, value)) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>  _state = <span class="hljs-title function_">value</span>(_state) <span class="hljs-comment">// 相当于传入prevalue后，return经过处理得到的新value</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  _state = value<br>  &#125;<br>    <span class="hljs-comment">// 通知视图更新</span><br>    <span class="hljs-comment">//...重新渲染组件</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> [_state, setState]; <span class="hljs-comment">// 数组是新的变量，里面的每项自然也是新的，栈地址也不相同</span><br>&#125;<br><br><span class="hljs-keyword">let</span> [num1, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始时num1=0  setNum=setState 0x001</span><br><span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//=&gt;_state=100 通知视图更新</span><br><span class="hljs-comment">// ---</span><br>再次执行整个函数组件，在执行到useState的时候：<br><span class="hljs-keyword">let</span> [num2, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//由于初次渲染时，全局state被赋值了，不再为undefined，所以不再赋值为initialState</span><br>在内部又产生了一个新的setState，地址和之前不同，使用这次新的闭包作为父级上下文<br>最后返回新的state和新的setState并被声明为新的变量<br>num2=<span class="hljs-number">100</span>  setNum=setState <span class="hljs-number">0x002</span><br></code></pre></td></tr></table></figure><h3 id="惰性初始-state——复杂的初始化逻辑只执行一次"><a href="#惰性初始-state——复杂的初始化逻辑只执行一次" class="headerlink" title="惰性初始 state——复杂的初始化逻辑只执行一次"></a>惰性初始 state——复杂的初始化逻辑只执行一次</h3><p>如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，<strong>此函数只在初始渲染时被调用，之后更新视图以后，状态值不再是 undefined，所以不会再执行初始的惰性回调</strong>！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; x, y &#125; = props;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：如果将回调里的逻辑写到外面，则一旦视图更新，不管是第一次还是后续更新的时候，这段逻辑都会执行。<strong>即使在更新阶段，num 不再是 undefined，初始值不再生效，这段逻辑依然会执行，浪费资源效率低下</strong></p><img src="/img/react/useState/image-20230616150504612.png" alt="image-20230616150504612" style="zoom:67%;" /><h3 id="useState-性能优化机制——Object-is-类似-PureComponent-的浅比较"><a href="#useState-性能优化机制——Object-is-类似-PureComponent-的浅比较" class="headerlink" title="useState 性能优化机制——Object.is 类似 PureComponent 的浅比较"></a>useState 性能优化机制——Object.is 类似 PureComponent 的浅比较</h3><p>useState 自带了性能优化的机制：</p><ul><li><strong>每一次修改状态值的时候，会拿最新要修改的值和之前的状态值做比较「基于 Object.is 作比较，而不是更严格的&#x3D;&#x3D;&#x3D;。如果前后状态都是 NaN，Object.is 返回 true 不更新状态和视图，&#x3D;&#x3D;&#x3D;返回 false 更新状态和视图」</strong></li><li><strong>如果发现两次的值是一样的，则不会修改状态，也不会让视图更新「可以理解为：类似于 PureComponent，在 shouldComponentUpdate 中做了浅比较和优化，注意函数组件中不可能有 PureComponent」</strong></li></ul><p>调用 State Hook 的更新函数，并传入当前的 state 时，React 将跳过组件的渲染（原因：React 使用 Object.is 比较算法，来比较新老 state；注意不是因为 DOM-DIFF；）！</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;render&quot;</span>);<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setNum(num);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        处理</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 核心原理：闭包</span><br><span class="hljs-keyword">var</span> _state; <span class="hljs-comment">// 创建全局state。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  _state = _state | initialState;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(_state, value)) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>  _state = <span class="hljs-title function_">value</span>(_state) <span class="hljs-comment">// 相当于传入prevalue后，return经过处理得到的新value</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  _state = value<br>  &#125;<br>    <span class="hljs-comment">// 通知视图更新</span><br>    <span class="hljs-comment">//...重新渲染组件</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> [_state, setState]; <span class="hljs-comment">// 数组是新的变量，里面的每项自然也是新的，栈地址也不相同</span><br>&#125;<br><span class="hljs-keyword">let</span> [num1, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始时num1=0  setNum=setState 0x001</span><br><span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//=&gt;_state=100 通知视图更新</span><br><span class="hljs-comment">// ---</span><br>再次执行整个函数组件，在执行到useState的时候：<br><span class="hljs-keyword">let</span> [num2, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//由于初次渲染时，全局state被赋值了，不再为undefined，所以不再赋值为initialState</span><br>在内部又产生了一个新的setState，地址和之前不同，使用这次新的闭包作为父级上下文<br>最后返回新的state和新的setState并被声明为新的变量<br>num2=<span class="hljs-number">100</span>  setNum=setState <span class="hljs-number">0x002</span><br></code></pre></td></tr></table></figure><h4 id="例-1-前后-state-浅比较-true，不更新状态和视图"><a href="#例-1-前后-state-浅比较-true，不更新状态和视图" class="headerlink" title="例 1 前后 state 浅比较 true，不更新状态和视图"></a>例 1 前后 state 浅比较 true，不更新状态和视图</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UseStateDemo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">UseStateDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;RENDER&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(<span class="hljs-number">10</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UseStateDemo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UseStateDemo</span>;<br></code></pre></td></tr></table></figure><p>不更新视图和状态</p><h4 id="例-2-更新多次，最终值-11"><a href="#例-2-更新多次，最终值-11" class="headerlink" title="例 2 更新多次，最终值 11"></a>例 2 更新多次，最终值 11</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UseStateDemo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">UseStateDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;RENDER&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>      <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setX</span>(x + <span class="hljs-number">1</span>);<br>      &#125;);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UseStateDemo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UseStateDemo</span>;<br></code></pre></td></tr></table></figure><p>render 两次（理论上是一次，这里是因为这些操作作用的都是一个闭包中的同一个状态值，在第一次改状态还没改成功之前，其他次操作访问的状态值仍旧是还没改的 10，直到第一次改状态成功，剩余次操作不会再通过 Object.is 的测试。这里 render 次数和浏览器的效率有关，不过绝对不是 10 次 ），最后状态值是 11</p><p><img src="/img/react/useState/6.png"></p><p>在第一次渲染时创造出来顶级的函数作用域，_state 私有属性就是在这个顶级作用域里面的</p><p>点击 handle 之后会执行 10 次同步清空更新队列的操作</p><p>在第一次 flushSync，更新队列里只有一个 setX，立即同步执行，使用的是第一次 Demo 创建出来的 EC 的闭包中的 state，也就是 10。进入 setX，通过了 Object.is 的比较，更新状态和视图，此时最外部的_state 也被更新为 11</p><p>第二次 flushSync，更新队列里只有一个 setX，立即同步执行，使用的也是第一次 Demo 创建出来的 EC 的闭包中的 state（因为这些 flushSync 方法都存在于第一个上下文中），也就是 10。进入 setX，未通过了 Object.is 的比较，因此不更新状态和视图</p><p>第三。。。十轮同样不更新</p><h4 id="例-3-更新-1-次，最终值-20-——函数式更新"><a href="#例-3-更新-1-次，最终值-20-——函数式更新" class="headerlink" title="例 3 更新 1 次，最终值 20 ——函数式更新"></a>例 3 更新 1 次，最终值 20 ——函数式更新</h4><p><img src="/img/react/useState/7.png"></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useState</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react hooks简介</title>
    <link href="/2023/06/01/Hooks%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/06/01/Hooks%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="React-组件回顾"><a href="#React-组件回顾" class="headerlink" title="React 组件回顾"></a>React 组件回顾</h2><h3 id="函数组件特点"><a href="#函数组件特点" class="headerlink" title="函数组件特点"></a>函数组件特点</h3><ul><li>不具备“状态、ref、周期函数”等内容，第一次渲染完毕后，无法基于组件内部的操作来控制其更新，因此称之为静态组件！</li><li>但是具备属性及插槽，父组件可以控制其重新渲染！</li><li>渲染流程简单，渲染速度较快！</li><li>基于 FP（函数式编程）思想设计，提供更细粒度的逻辑组织和复用！</li><li><strong>纯函数组件，无法改状态</strong></li></ul><h3 id="类组件特点"><a href="#类组件特点" class="headerlink" title="类组件特点"></a>类组件特点</h3><ul><li>具备“状态、ref、周期函数、属性、插槽”等内容，可以灵活的控制组件更新，基于钩子函数也可灵活掌控不同阶段处理不同的事情！</li><li>渲染流程繁琐，渲染速度相对较慢！</li><li>基于 OOP（面向对象编程）思想设计，更方便实现继承等！</li></ul><h3 id="React-Hooks-组件"><a href="#React-Hooks-组件" class="headerlink" title="React Hooks 组件"></a>React Hooks 组件</h3><p>就是基于 React 中新提供的 Hook 函数，可以 <code>让函数组件动态化</code>!</p><h2 id="Hook-函数概览"><a href="#Hook-函数概览" class="headerlink" title="Hook 函数概览"></a>Hook 函数概览</h2><p>Hook 是 React 16.8 的新增特性！并且只能运用到函数组件中！<br><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html">https://zh-hans.reactjs.org/docs/hooks-reference.html</a></p><ul><li>基础 Hook<ul><li><code>useState</code> 使用状态管理</li><li><code>useEffect</code> 使用周期函数</li><li><code>useContext</code> 使用上下文信息</li></ul></li><li>额外的 Hook<ul><li><code>useReducer</code> useState 的替代方案，借鉴 redux 处理思想，管理更复杂的状态和逻辑</li><li><code>useCallback</code> 构建缓存优化方案</li><li><code>useMemo</code> 构建缓存优化方案</li><li><code>useRef</code> 使用 ref 获取 DOM</li><li><code>useImperativeHandle</code> 配合 forwardRef（ref 转发）一起使用</li><li><code>useLayoutEffect</code> 与 useEffect 相同，但会在所有的 DOM 变更之后同步调用 effect</li><li>…</li></ul></li><li>自定义 Hook</li><li>……</li></ul>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
