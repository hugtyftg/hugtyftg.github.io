<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MongoDB初探</title>
    <link href="/2024/05/08/MongoDB%E5%88%9D%E6%8E%A2/"/>
    <url>/2024/05/08/MongoDB%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MongoDB是一个流行的开源NoSQL文档型数据库，由若干JSON格式且具备schema的document组成，可以在MongoDB Atlas云平台使用，并且内置服务性能分析模块等，非常强大。</p><p>本文分为mongoDB核心概念介绍、mongoose介绍和express实战三个方面。</p><h1 id="mongoDB核心概念"><a href="#mongoDB核心概念" class="headerlink" title="mongoDB核心概念"></a>mongoDB核心概念</h1><h2 id="数据库常规概念回顾"><a href="#数据库常规概念回顾" class="headerlink" title="数据库常规概念回顾"></a>数据库常规概念回顾</h2><p>每个database由多张table组成，每张table的构成如下：</p><p><img src="/img/database/mongoDB/image-20240508171015259.png" alt="image-20240508171015259"></p><h2 id="mongoDB-architecture"><a href="#mongoDB-architecture" class="headerlink" title="mongoDB architecture"></a>mongoDB architecture</h2><p><img src="/img/database/mongoDB/document-store-100893897-large.jpg" alt="document store"></p><h2 id="Mongo-Instance"><a href="#Mongo-Instance" class="headerlink" title="Mongo Instance"></a>Mongo Instance</h2><p>可以理解成一个server，管理多个database</p><h2 id="database"><a href="#database" class="headerlink" title="database"></a>database</h2><p>MongoDB中的database指的是数据的物理容器，一个MongoDB服务器包含多个数据库，每个数据库内都有一套独立的文件系统</p><p><img src="/img/database/mongoDB/mongodb-collection-vs-document.jpg" alt="Relational and non relational databases"></p><h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><p>collection是一组document的集合，通常可以被类比成关系型数据库中的表，不同的是collection没有schema约束，而document有schema。</p><p><img src="/img/database/mongoDB/crud-annotated-collection.bakedsvg.svg" alt="Databases and Collections - MongoDB Manual v7.0"></p><h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p>document是Field-Value键值对的集合（必须是JSON格式）。每个document都有<strong>动态schema结构</strong>，这意味着collection中每个document可能有截然不同的结构或fields，可能有相同的filed也可能没有</p><p>db.users是一个collection，通过调用insert方法向其中插入一个collection，或者通过insertMany插入多个collection</p><p>备注：一般来说不直接这样使用db，推荐使用mongoose连接和管理数据库，通过schema建立model，通过model操作对应数据</p><p><img src="/img/database/mongoDB/mongodb-data-structure.png" alt="MongoDB Data Types &amp; Field-Value Pairs | Studio 3T"></p><h2 id="Field-Value-Pair"><a href="#Field-Value-Pair" class="headerlink" title="Field-Value Pair"></a>Field-Value Pair</h2><p><img src="/img/database/mongoDB/JSON_Example_Python_MongoDB-mzqqz0keng.png" alt="MongoDB Data Types &amp; Field-Value Pairs | Studio 3T"></p><h1 id="mongoose介绍"><a href="#mongoose介绍" class="headerlink" title="mongoose介绍"></a>mongoose介绍</h1><p>mongoose是nodeJS环境下连接mongoDB的第三方库，是对数据库操作进行封装的对象模型工具，将数据库中的数据转换成javascript对象方便开发者使用，核心概念是schema和models</p><h2 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h2><p>mongoose中的一切都起源于一个schema，每个schema映射到MongoDB内collection中的document格式。</p><p>schema不仅定义了document的field和structure，还定义了<strong>文档实例方法、模型静态方法、复合索引</strong></p><p>schema是动态的</p><p>schema甚至可以约束<strong>枚举</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserSchema</span> = mongoose.<span class="hljs-title class_">Schema</span>(<br>  &#123;<br>    <span class="hljs-attr">name</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;String&#x27;</span>,<br>      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">min</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">max</span>: <span class="hljs-number">100</span>,<br>    &#125;,<br>...<br>  &#125;,<br>);<br></code></pre></td></tr></table></figure><h2 id="models"><a href="#models" class="headerlink" title="models"></a>models</h2><p>使用schema定义可以创建我们需要的数据模型model，便于在controller层操作使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// server/models/User.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, <span class="hljs-title class_">UserSchema</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// server/controller/general.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">User</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../models/User.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUser</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; id &#125; = req.<span class="hljs-property">params</span>;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">findById</span>(id);<br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>(user);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">json</span>(&#123;<br>      <span class="hljs-attr">code</span>: -<span class="hljs-number">1</span>,<br>      <span class="hljs-attr">message</span>: error.<span class="hljs-property">message</span>,<br>    &#125;);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="模型静态方法"><a href="#模型静态方法" class="headerlink" title="模型静态方法"></a>模型静态方法</h2><p>可以对通过schema创建的model进行操作，如findById、insertMany等方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">findById</span>(id);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">insertMany</span>(dataUser); <span class="hljs-comment">// dataUser是一个满足schema的对象数组</span><br></code></pre></td></tr></table></figure><h1 id="express-MongoDB-mongoose实战"><a href="#express-MongoDB-mongoose实战" class="headerlink" title="express+MongoDB+mongoose实战"></a>express+MongoDB+mongoose实战</h1><h2 id="0-预备工作"><a href="#0-预备工作" class="headerlink" title="0.预备工作"></a>0.预备工作</h2><p>登录<a href="https://cloud.mongodb.com/%E5%BB%BA%E7%AB%8Bdatabase%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8azure%E6%88%96%E8%80%85aws%E7%9A%84%E5%85%8D%E8%B4%B9%E8%B5%84%E6%BA%90%E5%BB%BA%E7%AB%8Bcluster">https://cloud.mongodb.com/建立database，可以使用azure或者aws的免费资源建立cluster</a></p><p>设置IP和User access白名单保证云端数据库的安全性</p><h2 id="1-mongoose连接数据库"><a href="#1-mongoose连接数据库" class="headerlink" title="1.mongoose连接数据库"></a>1.mongoose连接数据库</h2><p>在根目录下新建<code>.env</code>文件存放环境变量如MONGO_URL、PORT，通过dotenv读取信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">dotenv.<span class="hljs-title function_">config</span>(); <span class="hljs-comment">// 将.env敏感信息注入到环境中、能被process.env访问</span><br><span class="hljs-comment">/* MONGOOSE SETUP */</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> || <span class="hljs-number">9000</span>;<br>mongoose<br>  .<span class="hljs-title function_">connect</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">MONGO_URL</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`server is running at http://localhost:<span class="hljs-subst">$&#123;PORT&#125;</span>`</span>);<br>    &#125;);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><h2 id="2-model层建立schema和collection"><a href="#2-model层建立schema和collection" class="headerlink" title="2.model层建立schema和collection"></a>2.model层建立schema和collection</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> mongoose <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mongoose&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserSchema</span> = mongoose.<span class="hljs-title class_">Schema</span>(<br>  &#123;<br>    <span class="hljs-attr">name</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;String&#x27;</span>,<br>      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">min</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">max</span>: <span class="hljs-number">100</span>,<br>    &#125;,<br>    <span class="hljs-attr">email</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;String&#x27;</span>,<br>      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">max</span>: <span class="hljs-number">50</span>,<br>    &#125;,<br>    <span class="hljs-attr">password</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;String&#x27;</span>,<br>      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">min</span>: <span class="hljs-number">5</span>,<br>    &#125;,<br>    <span class="hljs-attr">city</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">country</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">occupation</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">phoneNumber</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">transactions</span>: <span class="hljs-title class_">Array</span>,<br>    <span class="hljs-attr">role</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;String&#x27;</span>,<br>      <span class="hljs-attr">enum</span>: [<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;superadmin&#x27;</span>],<br>      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>    &#125;,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">timestamps</span>: <span class="hljs-literal">true</span>,<br>  &#125;<br>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, <span class="hljs-title class_">UserSchema</span>);<br></code></pre></td></tr></table></figure><h2 id="3-controller层封装操作"><a href="#3-controller层封装操作" class="headerlink" title="3.controller层封装操作"></a>3.controller层封装操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">User</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../models/User.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUser</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; id &#125; = req.<span class="hljs-property">params</span>;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">findById</span>(id);<br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>(user);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">json</span>(&#123;<br>      <span class="hljs-attr">code</span>: -<span class="hljs-number">1</span>,<br>      <span class="hljs-attr">message</span>: error.<span class="hljs-property">message</span>,<br>    &#125;);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-暴露后端API并测试"><a href="#4-暴露后端API并测试" class="headerlink" title="4.暴露后端API并测试"></a>4.暴露后端API并测试</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"># server/routes/general.<span class="hljs-property">js</span><br><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; getUser &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../controller/general.js&#x27;</span>;<br><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, getUser);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"># server/index.<span class="hljs-property">js</span><br><span class="hljs-keyword">import</span> generaRoutes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routes/general.js&#x27;</span>;<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/general&#x27;</span>, generaRoutes);<br></code></pre></td></tr></table></figure><p>访问<a href="http://localhost:5001/general/user/63701cc1f03239b7f700000e%E5%8F%AF%E4%BB%A5%E6%AD%A3%E7%A1%AE%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE">http://localhost:5001/general/user/63701cc1f03239b7f700000e可以正确获取数据</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;63701cc1f03239b7f700000e&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Shelly&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;swelbeck12@ycombinator.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;RSjzmAjnq&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Sangoleng&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;country&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ID&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;occupation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Pharmacist&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;phoneNumber&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;7036619983&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;transactions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;63701d74f03239d81e000027&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;63701d74f032396b8e00002c&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;63701d74f032396b8e000037&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;63701d74f03239d81e00002a&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;63701d74f03239c72c0001ba&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;63701d74f032399c00000151&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;63701d74f03239c72c0001a1&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;role&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;superadmin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;__v&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;createdAt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2024-05-08T07:06:12.736Z&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;updatedAt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2024-05-08T07:06:12.736Z&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
      <category>MongoDB</category>
      
      <category>NoSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP实现HTTP服务</title>
    <link href="/2024/02/02/TCP%E5%AE%9E%E7%8E%B0HTTP%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/02/02/TCP%E5%AE%9E%E7%8E%B0HTTP%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>TCP 协议是传输层协议，有端口概念，可以基于此实现应用层 HTTP 报文收发</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 基于传输层的TCP协议实现应用层HTTP</span><br><span class="hljs-keyword">import</span> net <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;net&#x27;</span>;<br><span class="hljs-keyword">const</span> statusLine = <span class="hljs-string">&#x27;HTTP/1.1 200 OK&#x27;</span>;<br><span class="hljs-keyword">const</span> resBody = <span class="hljs-string">&#x27;&lt;h1&gt;20240202&lt;/h1&gt;&#x27;</span>;<br><span class="hljs-keyword">const</span> resHeader = [<br>  <span class="hljs-string">&#x27;Content-Type: text/html&#x27;</span>,<br>  <span class="hljs-string">`Content-Length: <span class="hljs-subst">$&#123;resBody.length&#125;</span>`</span>,<br>  <span class="hljs-string">`Date: <span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toUTCString()&#125;</span>`</span>,<br>];<br><span class="hljs-comment">// HTTP响应报文结构</span><br><span class="hljs-comment">// 状态行 响应头 空行 响应体</span><br><span class="hljs-keyword">const</span> res = [statusLine, ...resHeader, <span class="hljs-string">&#x27;&#x27;</span>, resBody].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\r\n&#x27;</span>);<br><span class="hljs-keyword">const</span> tcp = net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 接收到数据的时候会自动调用</span><br>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/GET/</span>.<span class="hljs-title function_">test</span>(data.<span class="hljs-title function_">toString</span>())) &#123;<br>      socket.<span class="hljs-title function_">write</span>(res);<br>    &#125;<br>  &#125;);<br>&#125;);<br><br>tcp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server is running at http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS跨站脚本攻击</title>
    <link href="/2024/02/02/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"/>
    <url>/2024/02/02/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>网络应用程序的安全漏洞攻击——XSS 攻击</p><p>Cross-Site scripting 跨站脚本</p><h2 id="XSS-三种类型"><a href="#XSS-三种类型" class="headerlink" title="XSS 三种类型"></a>XSS 三种类型</h2><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 只是简单地把用户输入的数据<strong>从服务器反射给用户浏览器</strong>，黑客设计一个 URL 引导用户访问才能开展攻击</p><p>url 中包含信息甚至 script 脚本，一旦点击这个链接，script 就会执行，黑客可能会在 script 中写入木马</p><p>比如 <code>http://localhost:/index.html?a=&lt;script&gt;alter(1)&lt;/script&gt;</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const params = <span class="hljs-built_in">new</span> URLSearchParams(<span class="hljs-keyword">location</span>.<span class="hljs-keyword">search</span>)<br>const <span class="hljs-type">name</span> = params.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>console.log(<span class="hljs-type">name</span>);<br>document.<span class="hljs-keyword">write</span>(<span class="hljs-type">name</span>);<br></code></pre></td></tr></table></figure><h3 id="存储型-XSS（最严重）"><a href="#存储型-XSS（最严重）" class="headerlink" title="存储型 XSS（最严重）"></a>存储型 XSS（最严重）</h3><p>在线聊天室或者评论区比较常见，不需要特定的链接 URL，黑客仅仅需要在文本框中输入一段 script 脚本，如果前后端都没有过滤，那么这段脚本会被存储到数据库中，以后所有浏览这个被感染页面的人都会被这个脚本攻击，脚本中可能会窃取 cookie 等信息，信息资源盗刷</p><h3 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h3><p>也被称为客户端 XSS，利用 JS 与 HTML 的交互性质和 DOM 实现。</p><p>用户访问某个 URL 时，浏览器自动执行 JS 代码，恶有代码会被注入到当前页面，篡改内容或者盗取用户个人敏感信息</p><p><strong>不会触发 HTTP 请求和响应过程，攻击不会传递到服务端，仅仅在客户端</strong></p><h2 id="预防-XSS"><a href="#预防-XSS" class="headerlink" title="预防 XSS"></a>预防 XSS</h2><p>CSP（Content Security Policy）：通过设置响应报文头中的 CSP 策略，限制页面中可执行的脚本来源、样式表、图像、字体等，以此减少恶意代码等执行可能性</p><p>配置 CSP 规则</p><p>在服务端生成 CSP 规则，以 HTTP response header 的方式发送给浏览器如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span></span><br><span class="hljs-tag">  <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-scr &#x27;self&#x27;; script-src &#x27;self&#x27; cdn.example.com; style-src &#x27;self&#x27; fonts.googleapis.com&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure><ul><li>default-src 只能从当前源加载资源，例如 HTML 页面、图片、音频、视频等</li><li>script-src</li><li>style-src</li></ul><h2 id="CSP-策略"><a href="#CSP-策略" class="headerlink" title="CSP 策略"></a>CSP 策略</h2><h3 id="防止-XSS-攻击"><a href="#防止-XSS-攻击" class="headerlink" title="防止 XSS 攻击"></a>防止 XSS 攻击</h3><p>通过禁止外部脚本，例如第三方广告、恶意脚本等执行，防止 XSS 攻击</p><h3 id="防止数据泄露"><a href="#防止数据泄露" class="headerlink" title="防止数据泄露"></a>防止数据泄露</h3><p>通过禁止外部资源加载，防止敏感数据被窃取或者篡改</p><h3 id="防止点击劫持"><a href="#防止点击劫持" class="headerlink" title="防止点击劫持"></a>防止点击劫持</h3><p>通过禁止页面嵌入式 IFRAME，防止被钓鱼网站利用</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><h3 id="简单——利用正则将"><a href="#简单——利用正则将" class="headerlink" title="简单——利用正则将&gt; &lt;解析成文本实体，就不会将其解析成 script 标签了，前后端都要处理"></a>简单——利用正则将<code>&gt;</code> <code>&lt;</code>解析成文本实体，就不会将其解析成 script 标签了，前后端都要处理</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> textArea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;textarea&#x27;</span>);<br><span class="hljs-keyword">const</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>(textArea, content);<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">keyCode</span> === <span class="hljs-number">13</span>) &#123;<br>    <span class="hljs-comment">// content.innerHTML = textArea.value;</span><br>    <span class="hljs-comment">// 将&lt;&gt;变成字符实体，避免错误地执行黑客输入的脚本内容</span><br>    content.<span class="hljs-property">innerHTML</span> = textArea.<span class="hljs-property">value</span><br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&#x27;&amp;lt;&#x27;</span>)<br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&#x27;&amp;gt;&#x27;</span>);<br>    textArea.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="成熟——使用第三方-xss-库"><a href="#成熟——使用第三方-xss-库" class="headerlink" title="成熟——使用第三方 xss 库"></a>成熟——使用第三方 xss 库</h2>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络状态 强网弱网环境</title>
    <link href="/2024/02/01/%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81&amp;%E5%BC%BA%E7%BD%91%E5%BC%B1%E7%BD%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/02/01/%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81&amp;%E5%BC%BA%E7%BD%91%E5%BC%B1%E7%BD%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="前端获取网络状态"><a href="#前端获取网络状态" class="headerlink" title="前端获取网络状态"></a>前端获取网络状态</h1><h2 id="navigator-onLine-获取网络环境状态"><a href="#navigator-onLine-获取网络环境状态" class="headerlink" title="navigator.onLine 获取网络环境状态"></a><code>navigator.onLine</code> 获取网络环境状态</h2><p>除了使用事件监听器之外，JavaScript 还提供了另一种方式来检测浏览器的网络连接状态，即使用 <code>navigator.onLine</code> 属性。该属性<strong>返回一个布尔值，表示浏览器是否处于联网状态</strong>。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(navigator.onLine);<br></code></pre></td></tr></table></figure><h2 id="online-和-offline-事件及其处理函数"><a href="#online-和-offline-事件及其处理函数" class="headerlink" title="online 和 offline 事件及其处理函数"></a>online 和 offline 事件及其处理函数</h2><p><strong><code>online</code> 和 <code>offline</code> 事件是浏览器自带的两个事件，可以通过添加事件监听器来检测当前网络连接状态</strong>。当浏览器的网络连接发生变化，比如从在线状态切换到离线状态，或者从离线状态切换到在线状态时，这两个事件就会被触发。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">window.addEventListener(<span class="hljs-string">&#x27;online&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  console.log(<span class="hljs-string">&#x27;online&#x27;</span>);<br>&#125;);<br>window.addEventListener(<span class="hljs-string">&#x27;offline&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  console.log(<span class="hljs-string">&#x27;offline&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="navigator-connection"><a href="#navigator-connection" class="headerlink" title="navigator.connection"></a><code>navigator.connection</code></h2><p><code>navigator.connection</code> 是 Web API 中提供的一种获取网络连接相关信息的接口。</p><p>该接口返回的是一个 <code>NetworkInformation</code> 对象（只读），包含了多个关于用户设备网络连接状况的属性，如网络类型、带宽、往返时间等。</p><p>通过 <code>navigator.connection</code> API 能够获取的主要网络连接属性如下：</p><ul><li><code>downlink</code>: 当前网络连接的估计下行速度（单位为 Mbps）</li><li><code>downlinkMax</code>: 设备网络连接最大可能下行速度（单位为 Mbps）</li><li><strong><code>effectiveType</code>: 当前网络连接的估计速度类型（如 slow-2g、2g、3g、4g 等）和设备没有关系</strong></li><li><code>rtt</code>: 当前网络连接的估计往返时间（单位为毫秒）</li><li><code>saveData</code>: 是否处于数据节省模式</li></ul><p>除此之外，还有其他诸如 <code>type</code>、<code>onchange</code> 等属性，用于获取设备网络连接的类型和注册网络连接状态变化事件等功能。</p><h3 id="使用前检查浏览器是否支持"><a href="#使用前检查浏览器是否支持" class="headerlink" title="使用前检查浏览器是否支持"></a>使用前检查浏览器是否支持</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;connection&#x27;</span> in navigator) &#123;<br>  <span class="hljs-comment">// 支持 navigator.connection API</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(navigator.connection);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 不支持 navigator.connection API</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>网络状态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络状态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT（鉴权）</title>
    <link href="/2024/02/01/JWT/"/>
    <url>/2024/02/01/JWT/</url>
    
    <content type="html"><![CDATA[<h2 id="jwt-json-web-token"><a href="#jwt-json-web-token" class="headerlink" title="jwt(json web token)"></a>jwt(json web token)</h2><p><strong>用于鉴权，登录之后存储用户信息</strong></p><h3 id="生成的-token-令牌-格式"><a href="#生成的-token-令牌-格式" class="headerlink" title="生成的 token(令牌) 格式"></a>生成的 token(令牌) 格式</h3><p>三段，每段由<code>.</code>连接</p><p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwiaWF0IjoxNjg3Njc0NDkyLCJleHAiOjE2ODc3NjA4OTJ9.Y6eFGv4KXqUhlRHglGCESvcJEnyMkMwM1WfICt8xYC4</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="header-头部"><a href="#header-头部" class="headerlink" title="header 头部"></a>header 头部</h3><p>header 通常用 json 对象表示，并进行 Base64 URL 编码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>alg：代表所使用的签名算法，例如 HMAC SHA256（HS256）或 RSA 等</p><p>typ：代表令牌的类型，一般为 “JWT”。</p><h3 id="payload-载荷"><a href="#payload-载荷" class="headerlink" title="payload 载荷"></a>payload 载荷</h3><p>payload 也是一个 JSON 对象，同样进行 Base64 URL 编码。</p><p>负载包含所要传输的信息，例如用户的身份、权限等，但不是密码这种关键信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;iss&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;example.com&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;exp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1624645200</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;johndoe&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>iss：令牌颁发者（Issuer），代表该 JWT 的签发者。</p><p>exp：过期时间（Expiration Time），代表该 JWT 的过期时间，以 Unix 时间戳表示。</p><p>sub：主题（Subject），代表该 JWT 所面向的用户（一般是用户的唯一标识）。</p><p>自定义声明：可以添加除了预定义声明之外的任意其他声明。</p><h3 id="signature-签名"><a href="#signature-签名" class="headerlink" title="signature 签名"></a>signature 签名</h3><p><strong>签名是使用私钥对头部和负载进行加密的结果</strong></p><p><strong>用于验证令牌的完整性和真实性</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-built_in">HMACSHA256</span>(<br><span class="hljs-function"><span class="hljs-title">base64UrlEncode</span><span class="hljs-params">(header)</span></span> + <span class="hljs-string">&quot;.&quot;</span> +<br><span class="hljs-function"><span class="hljs-title">base64UrlEncode</span><span class="hljs-params">(payload)</span></span>,<br>secretKey<br>)<br></code></pre></td></tr></table></figure><h2 id="服务端-Express-实现-JWT"><a href="#服务端-Express-实现-JWT" class="headerlink" title="服务端 Express 实现 JWT"></a>服务端 Express 实现 JWT</h2><p>使用 jsonwebtoken.sign(infoObj, private_key_str, {expiresIn: ‘1h’})来生成 token</p><p>使用 const token &#x3D; req.headers.authorization || ‘’;从请求头中读 token</p><p>如果无法通过 token 验证，返回状态码 401</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pnpm</span> i express cors jsonwebtoken <span class="hljs-variable">@types</span>/express <span class="hljs-variable">@types</span>/cors <span class="hljs-variable">@types</span>/jsonwebtoken<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-keyword">import</span> cors <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;cors&#x27;</span>;<br><span class="hljs-keyword">import</span> jsonwebtoken <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>;<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">// 一般来说private key是在环境变量中配置，或者在一个单独的文件中</span><br><span class="hljs-keyword">const</span> private_key = <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment">// 支持解析json</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br><span class="hljs-comment">// 解决跨域</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>());<br><span class="hljs-comment">// 不支持解析urlencoded</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;));<br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>&#125;;<br><span class="hljs-comment">// 1.登陆返回前端token用于授权</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">body</span>.<span class="hljs-property">name</span> === user.<span class="hljs-property">name</span> &amp;&amp; req.<span class="hljs-property">body</span>.<span class="hljs-property">password</span> === user.<span class="hljs-property">password</span>) &#123;<br>    res.<span class="hljs-title function_">json</span>(&#123;<br>      <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">token</span>: jsonwebtoken.<span class="hljs-title function_">sign</span>(&#123; <span class="hljs-attr">id</span>: user.<span class="hljs-property">id</span> &#125;, private_key, &#123;<br>        <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&#x27;1h&#x27;</span>,<br>      &#125;), <span class="hljs-comment">// token过期时间为1h，后续可以修改为配置文件读取，失效之后要重新登陆授权</span><br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">401</span>).<span class="hljs-title function_">json</span>(&#123;<br>      <span class="hljs-attr">code</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;用户名或密码错误&#x27;</span>,<br>    &#125;);<br>  &#125;<br>&#125;);<br><span class="hljs-comment">// 2.只有token通过认证才能访问list，否则403</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 前端会把token放在请求头中 这是一个规范</span><br>  <span class="hljs-keyword">const</span> token = req.<span class="hljs-property">headers</span>.<span class="hljs-property">authorization</span> || <span class="hljs-string">&#x27;&#x27;</span>;<br>  jsonwebtoken.<span class="hljs-title function_">verify</span>(token, private_key, <span class="hljs-function">(<span class="hljs-params">err, decoded</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      res.<span class="hljs-title function_">status</span>(<span class="hljs-number">401</span>).<span class="hljs-title function_">json</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;token过期或无效&#x27;</span>,<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.<span class="hljs-title function_">json</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">data</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br>      &#125;);<br>    &#125;<br>  &#125;);<br>&#125;);<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server is running at http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="用户端-fetch"><a href="#用户端-fetch" class="headerlink" title="用户端 fetch"></a>用户端 fetch</h2><p>将 token 保存在 localStorage 中，同域的所有窗口都可以获取，浏览器关闭后 item 依然存在</p><p>location.href &#x3D; ‘.&#x2F;list.html’;实现原生页面跳转</p><p>一般来说 token 前面会加上’Bearer ‘前缀，这是一个 w3c 约定的规范，具体实施起来要前后台协商</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts">loginBtn?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/login&#x27;</span>, &#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>      <span class="hljs-attr">name</span>: (nameInput <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLInputElement</span>).<span class="hljs-property">value</span>,<br>      <span class="hljs-attr">password</span>: (pwdInput <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLInputElement</span>).<span class="hljs-property">value</span>,<br>    &#125;),<br>  &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (d.<span class="hljs-property">code</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;tk&#x27;</span>, d.<span class="hljs-property">token</span>);<br>        (nameInput <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLInputElement</span>).<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        (pwdInput <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLInputElement</span>).<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-comment">// 原生页面跳转</span><br>        <span class="hljs-comment">// localStorage支持同域访问</span><br>        location.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;./list.html&#x27;</span>;<br>      &#125;<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>身份验证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>身份验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSL TLS HTTPS</title>
    <link href="/2024/01/31/SSL%20TLS%20HTTPS/"/>
    <url>/2024/01/31/SSL%20TLS%20HTTPS/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTPS-http-TLS-SSL"><a href="#HTTPS-http-TLS-SSL" class="headerlink" title="HTTPS &#x3D; http + TLS&#x2F;SSL"></a>HTTPS &#x3D; http + TLS&#x2F;SSL</h2><p><strong>HTTPS，全称为 Hypertext Transfer Protocol Secure</strong>，是一种通过加密通道传输数据的安全协议。它是 <strong>HTTP 协议的安全版本，用于在 Web 浏览器和 Web 服务器之间进行安全的数据传输</strong>。HTTPS 在传输过程中使用了 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）协议来加密数据，确保敏感信息在传输过程中不会被窃取或篡改。</p><p><strong>注意：https 默认监听端口 443 http 默认监听端口 80</strong></p><h3 id="http-缺点"><a href="#http-缺点" class="headerlink" title="http 缺点"></a>http 缺点</h3><ol><li><strong>信息不加密：通信使用明文(不加密)，内容可能会被盗用</strong></li><li><strong>无身份校验：不验证通信方的身份，因此有可能遭遇伪装</strong></li><li><strong>无完整性验证：无法证明报文的完整性，所以有可能已遭篡改</strong></li></ol><h3 id="https-优点"><a href="#https-优点" class="headerlink" title="https 优点"></a>https 优点</h3><ol><li><p><strong>信息加密</strong></p></li><li><p><strong>身份验证</strong></p></li><li><p><strong>完整性校验</strong></p></li></ol><h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS SSL"></a>TLS SSL</h2><p>TLS（Transport Layer Security）和 SSL（Secure Sockets Layer）是用于保护网络通信的安全协议。它们都提供了<strong>加密和认证机制</strong>，用于确保数据传输的机密性和完整性。</p><p><strong>SSL 是最早的安全协议，而 TLS 是在 SSL 的基础上发展起来的。</strong>目前广泛使用的版本是 TLS 1.2 和 TLS 1.3。TLS 1.3 是最新的协议版本，在安全性、性能和功能方面有一些改进。</p><p>TLS 和 SSL 主要用于以下两个方面：</p><ol><li><strong>加密通信</strong>：TLS&#x2F;SSL 使用加密算法来对数据进行加密，防止第三方截获和窃听通信内容。它可以确保数据在传输过程中的隐私性。</li><li><strong>身份认证</strong>：TLS&#x2F;SSL 还提供了身份验证机制，用于确认通信双方的身份，并确保数据只发送到正确的接收方。这可以防止恶意用户冒充其他用户或服务器。</li></ol><p><strong>SSL 是最早的用来做 https 的，TLS 是 SSL 升级版。二者工作原理类似，但 TLS 提高了安全性，并解决了 SSL 存在的一些安全性问题和性能问题。</strong></p><h2 id="在-TCP-IP-四层模型中，TLS-SSL-在哪一层加密？"><a href="#在-TCP-IP-四层模型中，TLS-SSL-在哪一层加密？" class="headerlink" title="在 TCP&#x2F;IP 四层模型中，TLS SSL 在哪一层加密？"></a>在 TCP&#x2F;IP 四层模型中，TLS SSL 在哪一层加密？</h2><p>在应用层下、在传输层上，可以理解为“安全层”</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="对称加密-共有密钥"><a href="#对称加密-共有密钥" class="headerlink" title="对称加密 共有密钥"></a>对称加密 共有密钥</h3><p>常见的算法有 AES DES 加密</p><p>举例 <code>麒麟</code>-&gt;<code>星月</code>发消息 但是他们的消息不想被别人知道，采用了对称加密，于是他们两个协商了一段密钥，<code>今生永相随</code></p><p>麒麟：<code>AES算法 + 密钥（今生永相随）+明文（吃面） = XMZSXMZS==</code></p><p>星月：<code>使用AES + 密钥（今生永相随）+密文（ XMZSXMZS==） = 吃面</code></p><h3 id="非对称加密-一人分别一个公私钥"><a href="#非对称加密-一人分别一个公私钥" class="headerlink" title="非对称加密 一人分别一个公私钥"></a>非对称加密 一人分别一个公私钥</h3><p>常见算法有 RSA DSA 加密</p><p>举例 <code>麒麟</code>-&gt;<code>星月</code>发消息，这次使用的是非对称加密，生成了公钥和私钥，公钥可以对外公开，私钥必须只能<code>麒麟</code>知道不能泄露。</p><p>星月：RSA + 公钥 + 明文（吃面） &#x3D; XMZS&#x3D;&#x3D;</p><p>麒麟：RSA + 私钥 + 密文（XMZS&#x3D;&#x3D;） &#x3D; 吃面</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><h2 id="TLS-融合了对称加密、非对称加密以及散列函数实现加密，保证安全性"><a href="#TLS-融合了对称加密、非对称加密以及散列函数实现加密，保证安全性" class="headerlink" title="TLS 融合了对称加密、非对称加密以及散列函数实现加密，保证安全性"></a>TLS 融合了对称加密、非对称加密以及散列函数实现加密，保证安全性</h2><h2 id="TLS-证书"><a href="#TLS-证书" class="headerlink" title="TLS 证书"></a>TLS 证书</h2><p>在 SSL&#x2F;TLS 加密通信中，一般需要使用三个文件来完成证书相关操作，即：</p><ol><li><strong>私钥文件（例如 “private-key.pem”）</strong>，用于对加密数据进行解密操作。</li><li><strong>证书签名请求文件（例如 “certificate.csr”）</strong>，用于向 CA 申请 SSL&#x2F;TLS 证书签名。</li><li><strong>SSL&#x2F;TLS 证书文件（例如 “certificate.pem”）</strong>，用于对客户端发送的请求进行验证，以确保通信安全可靠。</li></ol><p>私钥文件用于对数据进行解密操作，保证了通信的机密性；证书签名请求文件包含了请求者的身份信息和公钥等信息，需要被发送给 CA 进行签名，从而获取有效的 SSL&#x2F;TLS 证书；SSL&#x2F;TLS 证书文件则包含了签名后的证书信息，被用于客户端和服务器之间的身份验证，以确保通信的安全性和可靠性。</p><p>通过使用这三个文件进行密钥交换和身份验证，SSL&#x2F;TLS 可以实现加密通信以及抵御可能的中间人攻击，提高了通信的安全性和保密性。</p><h2 id="openssl-生成加密证书"><a href="#openssl-生成加密证书" class="headerlink" title="openssl 生成加密证书"></a>openssl 生成加密证书</h2><h3 id="生成-private-key-pem-文件"><a href="#生成-private-key-pem-文件" class="headerlink" title="生成 private-key.pem 文件"></a>生成 private-key.pem 文件</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">openssl genpkey -algorithm RSA -<span class="hljs-keyword">out</span> <span class="hljs-keyword">private</span>-key.pem -aes256<br></code></pre></td></tr></table></figure><p>openssl: OpenSSL 命令行工具的名称。</p><p>genpkey: 生成私钥的命令。</p><p>-algorithm RSA: 指定生成 RSA 私钥。</p><p>-out private-key.pem: 将生成的私钥保存为 private-key.pem 文件。</p><p>-aes256: 为私钥添加 AES 256 位加密，以保护私钥文件不被未经授权的人访问。</p><p>Enter PEM pass phrase 密码短语生成 pem 文件的时候需要 123123</p><h3 id="生成-certificate-csr-文件"><a href="#生成-certificate-csr-文件" class="headerlink" title="生成 certificate.csr 文件"></a>生成 certificate.csr 文件</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing">openssl req -<span class="hljs-keyword">new</span> -<span class="hljs-built_in">key</span> <span class="hljs-keyword">private</span>-<span class="hljs-built_in">key</span>.<span class="hljs-property">pem</span> -out certificate.<span class="hljs-property">csr</span><br></code></pre></td></tr></table></figure><ol><li>“req”: 表示使用 X.509 证书请求管理器 (Certificate Request Management) 功能模块。</li><li>“-new”: 表示生成新的证书签名请求。</li><li>“-key private-key.pem”: 表示使用指定的私钥文件 “private-key.pem” 来加密证书签名请求中的密钥对。</li><li>“-out certificate.csr”: 表示输出生成的证书签名请求到文件 “certificate.csr” 中。该文件中包含了申请者提供的一些证书请求信息，例如公钥、授权主体的身份信息等。</li></ol><p>Country Name (2 letter code) []:CN 国家</p><p>State or Province Name (full name) []:BJ 省份</p><p>Locality Name (eg, city) []:BJ 城市</p><p>Organization Name (eg, company)ZMY 组织或者是个人</p><p>Organizational Unit Name (eg, section) []:XMKJ 机构名称</p><p>Common Name (eg, fully qualified host name) []:localhost 域名</p><p>Email Address []: 邮箱地址</p><p>Please enter the following ‘extra’ attributes</p><p>to be sent with your certificate request</p><p>A challenge password []: 密码加严 mmymmy</p><h3 id="生成-certificate-pem-文件"><a href="#生成-certificate-pem-文件" class="headerlink" title="生成 certificate.pem 文件"></a>生成 certificate.pem 文件</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">openssl x509 -req -<span class="hljs-keyword">in</span> certificate.csr -signkey <span class="hljs-keyword">private</span>-key.pem -<span class="hljs-keyword">out</span> certificate.pem<br></code></pre></td></tr></table></figure><p>“x509”: 表示使用 X.509 证书管理器功能模块。</p><p>“-req”: 表示从输入文件（这里为 “certificate.csr”）中读取证书签名请求数据。</p><p>“-in certificate.csr”: 指定要读取的证书签名请求文件名。</p><p>“-signkey private-key.pem”: 指定使用指定的私钥文件 “private-key.pem” 来进行签名操作。一般情况下，签名证书的私钥应该是和之前生成 CSR 的私钥对应的。</p><p>“-out certificate.pem”: 表示将签名后的证书输出到文件 “certificate.pem” 中。该文件中包含了签名后的证书信息，包括签名算法、有效期、公钥、授权主体的身份信息等。</p><p>Enter pass phrase for private-key.pem: 密码短语</p><h3 id="nodejs-接口测试-https"><a href="#nodejs-接口测试-https" class="headerlink" title="nodejs 接口测试 https"></a>nodejs 接口测试 https</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> https <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:https&#x27;</span>;<br><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<br><span class="hljs-regexp">//</span> https默认监听端口<span class="hljs-number">443</span> http默认监听端口<span class="hljs-number">80</span><br>https<br>  .createServer(<br>    &#123;<br>      key: fs.readFileSync(<span class="hljs-string">&#x27;./private-key.pem&#x27;</span>),<br>      cert: fs.readFileSync(<span class="hljs-string">&#x27;./certificate.pem&#x27;</span>),<br>      passphrase: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>      res.writeHead(<span class="hljs-number">200</span>);<br>      res.end(<span class="hljs-string">&#x27;success&#x27;</span>);<br>    &#125;<br>  )<br>  .listen(<span class="hljs-number">443</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    console.log(<span class="hljs-string">&#x27;server is runnig&#x27;</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>navigator.sendBeacon</title>
    <link href="/2024/01/30/navigator.sendBeacon/"/>
    <url>/2024/01/30/navigator.sendBeacon/</url>
    
    <content type="html"><![CDATA[<h2 id="发送网络请求的方式"><a href="#发送网络请求的方式" class="headerlink" title="发送网络请求的方式"></a>发送网络请求的方式</h2><ol><li>AJAX（xml 是代表）</li><li>fetch</li><li>sse</li><li>websocket</li><li>jsonp</li><li>image 的 src</li><li>navigator.sendBeacon</li></ol><h2 id="使用-navigator-sendBeacon-实现高效的数据上报"><a href="#使用-navigator-sendBeacon-实现高效的数据上报" class="headerlink" title="使用 navigator.sendBeacon 实现高效的数据上报"></a>使用 <code>navigator.sendBeacon</code> 实现高效的数据上报</h2><p>在 web 开发中，我们经常需要将用户行为或性能数据上报到服务器。为了不影响用户体验，开发者通常会在页面卸载时进行数据上报。然而，传统的数据上报方式，如 <code>XMLHttpRequest</code> 或 <code>Fetch API</code>，容易受到页面卸载过程中的阻塞，导致数据丢失。为了解决这个问题，<code>navigator.sendBeacon</code> API 被引入，它可以在页面卸载时安全、可靠地发送数据。</p><p><strong>navigator.sendBeacon 基于 ping 请求 是 html5 新增的 并且是 sendBeacon 特有的 ping 请求 只能携带少量数据，并且不需要等待服务端响应，因此非常适合做埋点统计，以及日志统计相关功能。</strong></p><h2 id="对比-ajax-fetch-的优点"><a href="#对比-ajax-fetch-的优点" class="headerlink" title="对比 ajax fetch 的优点"></a>对比 ajax fetch 的优点</h2><ol><li>fetch 和 ajax 受页面卸载过程的影响，而 sendBeacon 不受</li><li>异步执行，不阻塞页面关闭或跳转</li><li>原生支持发送跨域请求</li></ol><h2 id="对比-ajax-fetch-的缺点"><a href="#对比-ajax-fetch-的缺点" class="headerlink" title="对比 ajax fetch 的缺点"></a>对比 ajax fetch 的缺点</h2><ol><li><p>fetch 和 ajax 都可以发送任意请求 而 sendBeacon <strong>只能发送 POST。</strong></p></li><li><p>fetch 和 ajax 可以传输任意字节数据 而 sendBeacon <strong>只能传送少量数据（64KB 以内）</strong>，因为 ping 请求只能发送少量数据</p></li><li><p>fetch 和 ajax 可以定义任意请求头 而 sendBeacon <strong>无法自定义请求头</strong>，难以携带 token 等信息</p></li><li><p>sendBeacon 只能传输 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>ArrayBufferView</code></a>、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a>、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>DOMString</code></a>、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/FormData"><code>FormData</code></a> 或 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a> 类型的数据，<strong>不能直接传 JSON 数据</strong></p></li><li><p><strong>如果处于危险的网络环境比如公共网络，或者开启了广告屏蔽插件 此请求将无效</strong></p></li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>发送心跳包：可以使用 <code>navigator.sendBeacon</code> 发送心跳包，以保持与服务器的长连接，避免因为长时间没有网络请求而导致连接被关闭。</li><li><strong>数据埋点：可以使用 <code>navigator.sendBeacon</code> 在页面关闭或卸载时记录用户在线时间，pv uv，以及错误日志上报 按钮点击次数。</strong></li><li>发送用户反馈：可以使用 <code>navigator.sendBeacon</code> 发送用户反馈信息，如用户意见、bug 报告等，以便进行产品优化和改进</li></ol><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sendBeaconBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>sendBeaconBtn.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;send beacon&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(sendBeaconBtn);<br>sendBeaconBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// navigator.sendBeacon(&#x27;/api/sendBeacon/sendBeacon&#x27;);</span><br><br>  <span class="hljs-comment">// 传递json格式参数</span><br>  <span class="hljs-comment">// 只接受formdata blob arrayBuffer等数据格式，不支持json</span><br>  <span class="hljs-comment">// 所以需要手动转换一下数据格式</span><br>  <span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mmy&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span> &#125;);<br>  <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([json], &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;);<br>  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;/api/sendBeacon/sendBeacon&#x27;</span>, blob);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><span class="hljs-comment">// sendbeacon只能接受post</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/sendBeacon&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">body</span>);<br>  <span class="hljs-comment">// sendBeacon基于ping，有数据大小限制，返回数据应该保持轻量级</span><br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>客户端服务端通讯技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>客户端服务端通讯技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket</title>
    <link href="/2024/01/30/WebSocket/"/>
    <url>/2024/01/30/WebSocket/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>websocket 是一种建立在浏览器和服务器之间建立<strong>长时间稳定连接</strong>的技术，在单个 tcp 连接上进行<strong>全双工通信</strong>的网络协议，可以实现服务器（客户端）和服务器之间的双向数据包传递，且<strong>不受跨域限制</strong></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>客户端和服务端连续长时间互相通信如</p><ol><li>实时性要求较高的应用，如网络游戏、数据可视化大屏、在线聊天等</li><li>需要频繁交换数据的应用，比如在线编辑器、文件管理器等</li><li>需要推送服务的应用，比如实时数据监控、通知系统等</li><li>跨平台应用，比如桌面应用程序、移动应用程序</li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="全双工通讯"><a href="#全双工通讯" class="headerlink" title="全双工通讯"></a>全双工通讯</h3><p>长连接，server 和浏览器可以互相持续发送新数据</p><h3 id="技术实现——websocket-协议"><a href="#技术实现——websocket-协议" class="headerlink" title="技术实现——websocket 协议"></a>技术实现——websocket 协议</h3><p>基于特殊的升级协议（HTTP&#x2F;1.1 Upgrade 或 HTTP&#x2F;2）建立 TCP 连接。可以一个 server 对多个 client 通讯</p><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>文本和二进制数据</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>websocket 对象原生支持跨域</p><h3 id="WebSocket-事件"><a href="#WebSocket-事件" class="headerlink" title="WebSocket 事件"></a>WebSocket 事件</h3><ul><li><code>open</code>，</li><li><code>message</code>，</li><li><code>error</code>，</li><li><code>close</code>。</li></ul><h2 id="服务端使用"><a href="#服务端使用" class="headerlink" title="服务端使用"></a>服务端使用</h2><ol><li><p>创建 socket 服务实例、服务端口 const wsServer &#x3D; new ws.Server({ port: 8080 },cb);</p></li><li><p>监听客户端连接 wsServer.on(‘connection’, cb)</p></li><li><p>广播发送消息实现群聊 wsServer.clients</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一步，安装ws和ws的声明文件</span><br><span class="hljs-keyword">import</span> ws <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ws&#x27;</span>;<br><span class="hljs-comment">// 创建socket服务 8080端口</span><br><span class="hljs-keyword">const</span> wsServer = <span class="hljs-keyword">new</span> ws.<span class="hljs-title class_">Server</span>(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> &#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;socket service is running at ws://localhost:8080&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// 监听客户端/浏览器连接</span><br>wsServer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 监听客户端的消息</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;client connection&#x27;</span>);<br>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 消息广播实现群聊</span><br>    wsServer.<span class="hljs-property">clients</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">serverForClient</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 客户端传来的消息是buffer格式</span><br>      serverForClient.<span class="hljs-title function_">send</span>(e.<span class="hljs-title function_">toString</span>());<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-title function_">toString</span>());<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><ol><li><p>创建 websocket 实例 new WebSocket(‘ws:&#x2F;&#x2F;xxxx’)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// websocket 协议 ws wss</span><br><span class="hljs-keyword">const</span> wsClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:8080&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>监听是否连接成功 socket.addEventListener(‘open’, cb)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts">wsClient.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ws connection&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>向服务端发送消息 socket.send</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span> = input.<span class="hljs-property">value</span>;<br>  <span class="hljs-keyword">if</span> (input.<span class="hljs-property">value</span>) &#123;<br>    wsClient.<span class="hljs-title function_">send</span>(msg);<br>    input.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>监听服务端返回的消息 socket.addEventListener(‘message’, cb)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts">wsClient.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === state.<span class="hljs-property">MSG</span>) &#123;<br>    <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>    li.<span class="hljs-property">innerHTML</span> = e.<span class="hljs-property">data</span>;<br>    ul.<span class="hljs-title function_">appendChild</span>(li);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;heart check&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="消息广播（群聊）"><a href="#消息广播（群聊）" class="headerlink" title="消息广播（群聊）"></a>消息广播（群聊）</h3><p>服务端 wsServer.clients 以 set 形式存储每个连接 ws 的 client，遍历发送信息即可实现群聊</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">wsServer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 监听客户端的消息</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;client connection&#x27;</span>);<br>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 消息广播实现群聊</span><br>    wsServer.<span class="hljs-property">clients</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">serverForClient</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 客户端传来的消息是buffer格式</span><br>      serverForClient.<span class="hljs-title function_">send</span>(e.<span class="hljs-title function_">toString</span>());<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><ol><li>在实际使用过程中，由于网络波动、弱信号等原因，可能会导致 websocket 连接断开。</li><li>为了避免这种情况的发生，可以使用心跳机制来检测 websocket 是否正常连接</li><li>当发现连接断开时，可以尝试重新建立连接，并进行相应的处理</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pf">// socket长时间不使用 网络波动和弱网环境都会导致连接断开<br>// 心跳检测 进行保活 保持连接<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = &#123;<br>  HEART: <span class="hljs-number">1</span>,<br>  MSG: <span class="hljs-number">2</span>,<br>&#125;;<br>let heartInterval = <span class="hljs-built_in">set</span>Interval(heartCheck, <span class="hljs-number">3000</span>);<br>function heartCheck() &#123;<br>  // ws <span class="hljs-keyword">state</span> 为open才发送心跳，否则结束循环检测<br>  if (wsClient.readyState === wsClient.OPEN) &#123;<br>    wsClient.send(<br>      JSON.stringify(&#123;<br>        type: <span class="hljs-keyword">state</span>.HEART,<br>        message: &#x27;heart check&#x27;,<br>      &#125;)<br>    );<br>  &#125; else &#123;<br>    clearInterval(heartInterval);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>客户端服务端通讯技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>客户端服务端通讯技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSE（Server-Sent Event）</title>
    <link href="/2024/01/29/SSE/"/>
    <url>/2024/01/29/SSE/</url>
    
    <content type="html"><![CDATA[<h2 id="SSE-简介"><a href="#SSE-简介" class="headerlink" title="SSE 简介"></a>SSE 简介</h2><p>Server-Sent Event，是一种基于 HTTP 协议建立的服务端与浏览器之间的长连接，是一种单工通信方式，仅服务端向客户端发送消息</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="单工通讯"><a href="#单工通讯" class="headerlink" title="单工通讯"></a>单工通讯</h3><p>长连接，server 向浏览器持续发送新数据</p><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><p>基于 HTTP 协议</p><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>文本数据</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>浏览器跨域限制</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>open</p><p>message</p><p>Error</p><h2 id="服务端使用"><a href="#服务端使用" class="headerlink" title="服务端使用"></a>服务端使用</h2><ol><li><p>建立 SSE 连接</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">res.writeHead(<span class="hljs-number">200</span>, &#123;<br>  <span class="hljs-symbol">&#x27;Content</span>-<span class="hljs-keyword">Type</span>&#x27;: <span class="hljs-symbol">&#x27;text</span>/event-stream&#x27;,<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>自定义 SSE 事件名称，默认为 message</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">res.<span class="hljs-keyword">write</span>(<span class="hljs-string">&#x27;event:lyrics\n&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>返回数据</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">res</span>.write(`<span class="hljs-class"><span class="hljs-keyword">data</span>: $&#123;<span class="hljs-title">mockData</span>[<span class="hljs-title">current</span>]&#125;\n\n`);</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><ol><li><p>建立 SSE 连接</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> sse = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">&#x27;/api/sse/sse&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>监听消息。如果后端没有自定义事件名称，默认为 message</p><p>通过 e.data 获取消息</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">sse.addEventListener(<span class="hljs-string">&#x27;lyrics&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  content += e.data;<br>  divDOM.innerHTML = content<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>关闭连接</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">sse.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>客户端服务端通讯技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>客户端服务端通讯技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ajax xml fetch</title>
    <link href="/2024/01/29/ajax%20xml%20fetch/"/>
    <url>/2024/01/29/ajax%20xml%20fetch/</url>
    
    <content type="html"><![CDATA[<h1 id="AJAX-技术"><a href="#AJAX-技术" class="headerlink" title="AJAX 技术"></a>AJAX 技术</h1><p>ajax, Asynchronous Javascript and XML，异步 javascript 和 XML 技术，是一种早期的用于客户端和服务端异步数据交互的技术</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>在不刷新页面的情况下从服务器获取数据或提交表单，异步增量式更新页面内容</strong></p><p><strong>Ajax 通信与数据格式无关，数据格式并不一定是 XML</strong></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="提高用户体验"><a href="#提高用户体验" class="headerlink" title="提高用户体验"></a>提高用户体验</h3><p>通过减少页面的重载和刷新，使得网站变得更加灵活和动态。</p><h3 id="减轻服务器负载"><a href="#减轻服务器负载" class="headerlink" title="减轻服务器负载"></a>减轻服务器负载</h3><p>通过使用 Ajax，可以有效减少服务器接收到的请求次数和需要响应的数据量（相比 SSR），从而减轻服务器的负担。</p><h3 id="提高响应速度"><a href="#提高响应速度" class="headerlink" title="提高响应速度"></a>提高响应速度</h3><p>使用 Ajax 可以异步获取数据并更新页面，从而提高响应速度。</p><h3 id="增加交互性"><a href="#增加交互性" class="headerlink" title="增加交互性"></a>增加交互性</h3><p>通过使用 Ajax，可以使得页面变得更加动态和交互性。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="不利于-SEO"><a href="#不利于-SEO" class="headerlink" title="不利于 SEO"></a>不利于 SEO</h3><p>动态生成网站内容、依赖用户的交互，而 SEO 主要检测静态内容</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>在使用 Ajax 时，需要考虑数据安全性和网络安全性问题，并采取相应的措施加以防范。</p><h1 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h1><p><code>XMLHttpRequest</code> 是一个内建的浏览器对象</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1-创建-XML-对象"><a href="#1-创建-XML-对象" class="headerlink" title="1.创建 XML 对象"></a>1.创建 XML 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br></code></pre></td></tr></table></figure><h3 id="2-xhr-open-初始化"><a href="#2-xhr-open-初始化" class="headerlink" title="2.xhr.open()初始化"></a>2.xhr.open()初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">open</span>(method, <span class="hljs-variable constant_">URL</span>, [<span class="hljs-keyword">async</span>, user, password]);<br></code></pre></td></tr></table></figure><p>此方法指定请求的主要参数：</p><ul><li><code>method</code> —— HTTP 方法。通常是 <code>&quot;GET&quot;</code> 或 <code>&quot;POST&quot;</code>。</li><li><code>URL</code> —— 要请求的 URL，通常是一个字符串，也可以是 <a href="https://zh.javascript.info/url">URL</a> 对象。</li><li><code>async</code> —— 如果显式地设置为 <code>false</code>，那么请求将会以同步的方式处理，我们稍后会讲到它。</li><li><code>user</code>，<code>password</code> —— HTTP 基本身份验证（如果需要的话）的登录名和密码。</li></ul><p>请注意，<code>open</code> 调用与其名称相反，不会建立连接。它仅配置请求，而网络活动仅以 <code>send</code> 调用开启。</p><h3 id="3-xhr-send-发送请求"><a href="#3-xhr-send-发送请求" class="headerlink" title="3.xhr.send()发送请求"></a>3.xhr.send()发送请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">send</span>([body]);<br></code></pre></td></tr></table></figure><p>这个方法会建立连接，并将请求发送到服务器。可选参数 <code>body</code> 包含了 request body。</p><p>一些请求方法，像 <code>GET</code> 没有 request body。还有一些请求方法，像 <code>POST</code> 使用 <code>body</code> 将数据发送到服务器。</p><h3 id="4-监听状态变化"><a href="#4-监听状态变化" class="headerlink" title="4.监听状态变化"></a>4.监听状态变化</h3><h4 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h4><p>一个回调函数，在每次状态发生变化时被调用。</p><ul><li>readyState 0：未初始化，XMLHttpRequest 对象已经创建，但未调用 open 方法。</li><li>readyState 1：已打开，open 方法已经被调用，但 send 方法未被调用。</li><li>readyState 2：已发送，send 方法已经被调用，请求已经被服务器接收。</li><li>readyState 3：正在接收，服务器正在处理请求并返回数据。</li><li>readyState 4：完成，服务器已经完成了数据传输。</li></ul><p>注意还需要检测 HTTP response status，即 HTTP 响应码是否为 200</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(JSON.parse(xhr.response));<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="onLoad-onError-onProgress"><a href="#onLoad-onError-onProgress" class="headerlink" title="onLoad onError onProgress"></a>onLoad onError onProgress</h4><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="1-GET"><a href="#1-GET" class="headerlink" title="1.GET"></a>1.GET</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// get txt</span><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/api/txt&#x27;</span>, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-title function_">send</span>();<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-keyword">const</span> divDOM = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    divDOM.<span class="hljs-property">innerHTML</span> = xhr.<span class="hljs-property">responseText</span>;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divDOM);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;failed&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-POST-application-json-格式参数"><a href="#2-POST-application-json-格式参数" class="headerlink" title="2.POST application&#x2F;json 格式参数"></a>2.POST application&#x2F;json 格式参数</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/api/post&#x27;</span>);<br>xhr.send(<span class="hljs-built_in">JSON</span>.stringify(&#123;<br>  name: <span class="hljs-string">&#x27;mmy&#x27;</span><br>&#125;))<br>xhr.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span>) &#123;<br>    console.log(<span class="hljs-built_in">JSON</span>.parse(xhr.response));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-POST-application-x-www-form-urlencoded-格式参数"><a href="#3-POST-application-x-www-form-urlencoded-格式参数" class="headerlink" title="3.POST application&#x2F;x-www-form-urlencoded 格式参数"></a>3.POST application&#x2F;x-www-form-urlencoded 格式参数</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/api/post&#x27;</span>);<br>xhr.send(<span class="hljs-string">&#x27;name=mmy&#x27;</span>)<br>xhr.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(JSON.parse(xhr.response));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-中断请求"><a href="#4-中断请求" class="headerlink" title="4.中断请求"></a>4.中断请求</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">xhr.abort();<br>xhr.addEventListener(<span class="hljs-string">&#x27;abort&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;我被中断了&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="5-设置超时"><a href="#5-设置超时" class="headerlink" title="5.设置超时"></a>5.设置超时</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">xhr.timeout = <span class="hljs-number">3000</span>;<br>xhr.addEventListener(<span class="hljs-string">&#x27;timeout&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;响应超时&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-监听进度"><a href="#6-监听进度" class="headerlink" title="6.监听进度"></a>6.监听进度</h3><p>监听 progress 事件，通过 event.loaded 和 event.total 属性获取已上传数据量和总数据量，并计算上传进度，最后将进度显示在页面上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;progress&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#progress&#x27;</span>).<span class="hljs-property">innerText</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;(event.loaded / event.total * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h1><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let promise = <span class="hljs-keyword">fetch</span>(url, [<span class="hljs-keyword">options</span>])<br></code></pre></td></tr></table></figure><ul><li><strong><code>url</code></strong> —— 要访问的 URL。</li><li><strong><code>options</code></strong> —— 可选参数：method，header 等<ul><li>method</li><li>headers<ul><li>Content-Type</li><li>…</li></ul></li><li>body</li><li>singal</li><li>credentials</li><li>…</li></ul></li></ul><p><strong>第一阶段，当服务器发送了响应头（response header），<code>fetch</code> 返回的 <code>promise</code> 就使用内建的 <a href="https://fetch.spec.whatwg.org/#response-class">Response</a> class 对象来对响应头进行解析。</strong>在这个阶段，我们可以通过 status 检查响应头的 HTTP 状态码，来检查 HTTP 状态以确定请求是否成功，当前还没有响应体（response body）。</p><p><strong>第二阶段，为了获取 response body，我们需要使用一个其他的方法调用。</strong>返回数据的格式有五种</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">text</span><span class="hljs-params">()</span></span> 将响应体解析为纯文本字符串并返回<br><span class="hljs-function"><span class="hljs-title">json</span><span class="hljs-params">()</span></span> 将响应体解析为JSON格式并返回一个Javascript对象<br><span class="hljs-function"><span class="hljs-title">blob</span><span class="hljs-params">()</span></span> 将响应体解析为二进制数据并返回一个Blob对象<br><span class="hljs-function"><span class="hljs-title">arrayBuffer</span><span class="hljs-params">()</span></span> 将响应体解析为二进制数据并返回一个ArrayBuffer对象<br><span class="hljs-function"><span class="hljs-title">formData</span><span class="hljs-params">()</span></span> 将响应体解析为FormData对象<br></code></pre></td></tr></table></figure><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><h3 id="1-GET（默认）"><a href="#1-GET（默认）" class="headerlink" title="1.GET（默认）"></a>1.GET（默认）</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// GET</span><br><span class="hljs-comment">// 第一次返回的是response header，此时还没有response body</span><br><span class="hljs-comment">// 第二次根据数据解析方法返回response body</span><br>fetch(<span class="hljs-string">&#x27;http://localhost:5173/api/txt&#x27;</span>)<br>.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);<br>  <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">text</span>()<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-POST-application-json"><a href="#2-POST-application-json" class="headerlink" title="2.POST application&#x2F;json"></a>2.POST application&#x2F;json</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// POST application/json</span><br><span class="hljs-built_in">fetch</span>(<span class="hljs-string">&#x27;/api/post&#x27;</span>, &#123;<br>  method: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  headers: &#123;<br>    <span class="hljs-string">&#x27;Content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>  &#125;,<br>  <span class="hljs-selector-tag">body</span>: JSON<span class="hljs-selector-class">.stringify</span>(&#123;<br>    name: <span class="hljs-string">&#x27;mmy&#x27;</span>,<br>    age: <span class="hljs-number">23</span><br>  &#125;)<br>&#125;)<span class="hljs-selector-class">.then</span>((res) =&gt; res<span class="hljs-selector-class">.json</span>())<br>  <span class="hljs-selector-class">.then</span>(data =&gt; console<span class="hljs-selector-class">.log</span>(data))<br></code></pre></td></tr></table></figure><h3 id="3-POST-application-x-www-form-urlencoded"><a href="#3-POST-application-x-www-form-urlencoded" class="headerlink" title="3.POST application&#x2F;x-www-form-urlencoded"></a>3.POST application&#x2F;x-www-form-urlencoded</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// POST application/x-www-form-urlencoded</span><br>fetch(<span class="hljs-string">&#x27;http://localhost:5173/api/post&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;name=mmy&amp;age=23&#x27;</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data);<br>  &#125;)<br></code></pre></td></tr></table></figure><h3 id="4-上传进度"><a href="#4-上传进度" class="headerlink" title="4.上传进度"></a>4.上传进度</h3><p>通过请求头的 header.get(‘Content-Type’)获取总数据字节数。</p><p>通过请求头的 body.getReader()获取一个流数据读取器，循环累计当前读取的字节数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/txt&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">async</span> (res) =&gt; &#123;<br>  <span class="hljs-comment">// 由于当前的res已经被用于流式返回数据了，因此要复制出来一份response header用于返回response body</span><br>  <span class="hljs-keyword">const</span> response = res.<span class="hljs-title function_">clone</span>();<br>  <span class="hljs-comment">// 流式数据处理，返回一个流</span><br>  <span class="hljs-keyword">const</span> reader = res.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();<br>  <span class="hljs-comment">// 总长度，单位是字节</span><br>  <span class="hljs-keyword">const</span> total = res.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;Content-Length&#x27;</span>);<br>  <span class="hljs-comment">// 当前长度</span><br>  <span class="hljs-keyword">let</span> loaded = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 和iterator generator返回格式一样</span><br>    <span class="hljs-comment">// 如果done是true表示数据返回完毕</span><br>    <span class="hljs-comment">// value返回一个unit8Array</span><br>    <span class="hljs-keyword">const</span> &#123; done, value &#125; = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();<br>    <span class="hljs-keyword">if</span> (done) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    loaded += value.<span class="hljs-property">length</span> || <span class="hljs-number">0</span>;<br>    progressDOM.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`current progress: <span class="hljs-subst">$&#123;(loaded / total * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">text</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">length</span>);<br>&#125;)<br>  <span class="hljs-comment">// 终止 Promise返回reject</span><br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>  &#125;)<br></code></pre></td></tr></table></figure><h3 id="5-中断请求"><a href="#5-中断请求" class="headerlink" title="5.中断请求"></a>5.中断请求</h3><ol><li>初始化一个终止器 abort</li><li>发起 fetch 时标记 signal 为 abort.signal</li><li>合适的时候调用 abort.abort()</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btnDOM = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>btnDOM.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;abort post request&#x27;</span><br>btnDOM.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;abort&#x27;</span>);<br>  <span class="hljs-comment">// 终止</span><br>  abort.<span class="hljs-title function_">abort</span>();<br>&#125;)<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(btnDOM)<br><span class="hljs-comment">// 声明变量</span><br><span class="hljs-keyword">const</span> abort = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:5173/api/post&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>  &#125;,<br>  <span class="hljs-comment">// 打标记</span><br>  <span class="hljs-attr">signal</span>: abort.<span class="hljs-property">signal</span>,<br>  <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;name=mmy&amp;age=23&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  &#125;)<br></code></pre></td></tr></table></figure><h3 id="6-超时终止（手动实现）"><a href="#6-超时终止（手动实现）" class="headerlink" title="6.超时终止（手动实现）"></a>6.超时终止（手动实现）</h3><p>超时——手动封装一个计时器，timeout 时终止</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const timeoutFn = <span class="hljs-function"><span class="hljs-params">(time = <span class="hljs-number">1000</span>)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    abort.abort()<br>  &#125;, time);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-携带-cookie-和-HTTP-Authorization-header"><a href="#7-携带-cookie-和-HTTP-Authorization-header" class="headerlink" title="7.携带 cookie 和 HTTP-Authorization header"></a>7.携带 cookie 和 HTTP-Authorization header</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">fetch(&#x27;/api/txt&#x27;, &#123;<br>  headers: &#123;<br>    &#x27;Cookie&#x27;: &#x27;cookie_name=<span class="hljs-number">22471226</span>6&#x27;<br>  &#125;,<br>  <span class="hljs-comment">// cookie</span><br>  credentials: &#x27;include&#x27;<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="AJAX-XML-Axios-Fetch-综合比较"><a href="#AJAX-XML-Axios-Fetch-综合比较" class="headerlink" title="AJAX XML Axios Fetch 综合比较"></a>AJAX XML Axios Fetch 综合比较</h1><p>Ajax 是一种早期的客户端和服务端异步数据交互技术，最重要的实现之一就是 XMLHttpRequest 对象，因此 Ajax 也可以理解成是一种使用 XML 通信、获取网络资源的技术。</p><p>Axios 是一种基于 XML 进行二次封装的类库，在 XML 基础上实现了新的功能，比如请求拦截器、响应拦截器。XML 本身异步逻辑是通过回调函数实现的，axios 基于 Promise 对 XML 封装，使得写法更加简洁易用</p><p>Fetch API 是一种更现代的网络请求技术，是一种不同于 Ajax 的技术，有如下优点</p><ol><li>原生支持 Promise 和链式调用（XML 是回调函数实现的异步逻辑）</li><li>关注点分离的设计原则，API 更简洁、不同阶段的功能不过分耦合，写法简单（XML 需要进行多个参数和回调函数的配置）</li><li>丰富的请求和响应的数据类型支持，包括 JSON、FormData、Blob、ArrayBuffer 等，支持流式数据处理（XML 只支持文本和二进制数据）</li><li>可以和其他现代 Javascript API 配合使用如 Service Worker 等</li><li>跨域请求：<code>fetch</code> API 提供了一种简单而强大的解决方案——使用 CORS（跨域资源共享）头部实现跨域请求，而 XHR 则使用了一个叫做 <code>XMLHttpRequest Level 2</code> 的规范，在代码编写上相对较为繁琐。</li></ol><p>缺点</p><ol><li><p>没有原生支持 timeout 事件，需要自己实现</p></li><li><p>取消请求不方便，需要基于一个构造函数</p></li><li><p>相比于 Axios 第三方库使用比较繁琐，比如 request interceptor 和 response interceptor 需要自己实现</p></li><li><p><code>fetch</code> API 默认只支持 GET 和 POST 请求方法，而 XHR 则支持所有标准的 HTTP 请求方法。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>客户端服务端通讯技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>客户端服务端通讯技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决跨域——运维端nginx</title>
    <link href="/2024/01/28/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E2%80%94%E2%80%94%E8%BF%90%E7%BB%B4%E7%AB%AFnginx/"/>
    <url>/2024/01/28/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E2%80%94%E2%80%94%E8%BF%90%E7%BB%B4%E7%AB%AFnginx/</url>
    
    <content type="html"><![CDATA[<p>ubuntu</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">apt-get nginx<br>cd etc/nginx/sites-available/<span class="hljs-keyword">default</span><br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/api</span> &#123;<br>proxy_pass http://server_ip:server_port;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>CORS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer network</tag>
      
      <tag>CORS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决跨域——前后端协商jsonp</title>
    <link href="/2024/01/28/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E2%80%94%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%8D%8F%E5%95%86jsonp/"/>
    <url>/2024/01/28/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E2%80%94%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%8D%8F%E5%95%86jsonp/</url>
    
    <content type="html"><![CDATA[<h1 id="JSONP-原理"><a href="#JSONP-原理" class="headerlink" title="JSONP 原理"></a>JSONP 原理</h1><h2 id="1-什么是-JSONP"><a href="#1-什么是-JSONP" class="headerlink" title="1.什么是 JSONP"></a>1.什么是 JSONP</h2><p>JSONP（JavaScript with padding）是 JSON 的一种“使用方式”，可用于解决主流浏览器的跨域数据访问问题。</p><h2 id="2-JSONP-原理"><a href="#2-JSONP-原理" class="headerlink" title="2.JSONP 原理"></a>2.JSONP 原理</h2><p>由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是<code>&lt;script&gt;</code>标签不受浏览器同源策略的影响，所以可以通过 src 属性，请求非同源的 js 脚本。</p><p>因此，JSONP 的实现原理是，通过<code>&lt;script&gt;</code>标签的 src 属性，请求跨域的数据接口，并通过<strong>函数调用</strong>的形式，接收跨域接口响应回来的</p><p>数据</p><h2 id="3-执行过程"><a href="#3-执行过程" class="headerlink" title="3.执行过程"></a>3.执行过程</h2><p>1.客户端定义一个解析函数,如 jsonpCallback &#x3D; function(res){}</p><p>2.通过 params 的形式(d)包装 script 标签的请求参数,并且声明执行函数(如 cbj&#x3D;jsonpCallback)</p><p>3.后端获取到前端声明的执行函数(jsonpCallback)，并以带上参数且调用执行函数的方式传递给前端</p><p>4.前端在 script 标签返回资源的时候就会去执行 jsonpCallback 并通过回调函数的方式拿到数据了。</p><h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><p>由于 JSONP 是通过<code>&lt;script&gt;</code>标签的 src 属性+回调函数实现的跨域数据请求，所以 JSONP<strong>只支持 GET 数据请求，而不支持 POST 请求</strong>。</p><h2 id="JSONP-和-AJAX-区别"><a href="#JSONP-和-AJAX-区别" class="headerlink" title="JSONP 和 AJAX 区别"></a>JSONP 和 AJAX 区别</h2><p>jsonp 和 Ajax 没有任何关系,因为 jsonp 没有用到 XMLHttpRequest 这个对象</p><p>jsonp 之所以能跨域，是因为他并不是发送 ajax 请求，并不是利用 XMLHTTPRequest 对象和服务端进行通信，他其实是利用动态创建的 script 标签，而 script 标签是没有<a href="https://so.csdn.net/so/search?q=%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5&spm=1001.2101.3001.7020">同源策略</a>限制的，可以跨域的</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="前端-5500-端口"><a href="#前端-5500-端口" class="headerlink" title="前端 5500 端口"></a>前端 5500 端口</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>跨域的四种解决办法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// 1.jsonp 原理是通过不受浏览器跨域限制的script标签的src属性跨域请求数据</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 缺点：只能发送GET请求，不安全并且难以维护</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 后端返回的是一个函数，但是这个函数是在前端定义的，把值注入到函数参数中</span></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">jsonp</span> = (<span class="hljs-params">name</span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);</span><br><span class="language-javascript">        script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://localhost:3000/api/jsonp?callback=&#x27;</span> + name;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">window</span>[name] = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">resolve</span>(data);</span><br><span class="language-javascript">          &#125;;</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">      <span class="hljs-title function_">jsonp</span>(<span class="hljs-string">`callback<span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()&#125;</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="后端-3000-端口"><a href="#后端-3000-端口" class="headerlink" title="后端 3000 端口"></a>后端 3000 端口</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/jsonp&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; callback &#125; = req.<span class="hljs-property">query</span>;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>(&#x27;jsonp data from backend&#x27;)`</span>);<br>&#125;);<br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server is running&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">pnpm <span class="hljs-keyword">init</span><br>pnpm i express <span class="hljs-meta">@types</span>/express <span class="hljs-meta">@types</span>/node<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>CORS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer network</tag>
      
      <tag>CORS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决跨域——后端CORS</title>
    <link href="/2024/01/28/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AFCORS/"/>
    <url>/2024/01/28/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AFCORS/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-CORS"><a href="#什么是-CORS" class="headerlink" title="什么是 CORS"></a>什么是 CORS</h1><p>Cross origin resource sharing，跨域资源共享，主要出现在两种情况下：</p><ol><li><p>前后端分离的开发模式下（separation of front and back stage），前后端服务运行在不同的 domain，前端请求后端数据属于 CORS</p></li><li><p>前端请求第三方不同 domain 的数据资源</p></li></ol><h1 id="CORS-分类"><a href="#CORS-分类" class="headerlink" title="CORS 分类"></a>CORS 分类</h1><p>默认情况下的跨域请求过程主要分为两类：第一类是<strong>安全请求</strong>，浏览器直接发送实际请求；第二类是<strong>非安全请求</strong>，浏览器需要先发送<strong>预检请求 preflight</strong>，在根据 preflight response 决定是否发送实际请求。</p><p><strong>附带凭据的跨域请求</strong>更加严格，因为它携带了 cookies 或者 HTTP 认证（HTTP authentication）等敏感数据</p><p>每种请求的场景和具体过程可参考以下资源</p><p><a href="https://zh.javascript.info/fetch-crossorigin#ping-ju-credentials">https://zh.javascript.info/fetch-crossorigin#ping-ju-credentials</a></p><p><a href="https://www.bilibili.com/video/BV1T5411v7to/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=d72819370cfa974d3b9e47dee41c7878">https://www.bilibili.com/video/BV1T5411v7to/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=d72819370cfa974d3b9e47dee41c7878</a></p><p><a href="https://www.bilibili.com/video/BV1rL411a7UN?p=6&vd_source=d72819370cfa974d3b9e47dee41c7878">https://www.bilibili.com/video/BV1rL411a7UN?p=6&amp;vd_source=d72819370cfa974d3b9e47dee41c7878</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>前端 <a href="http://localhost:5173/">http://localhost:5173/</a></p><p>后端 <a href="http://localhost:3000/">http://localhost:3000/</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/json&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 3.后端添加CORS request header</span><br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mameiyu&#x27;</span> &#125;);<br>&#125;);<br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server is running&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>跨域的四种解决办法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// 3.CORS</span></span><br><span class="language-javascript">      <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/api/json&#x27;</span>)</span><br><span class="language-javascript">        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())</span><br><span class="language-javascript">        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>CORS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer network</tag>
      
      <tag>CORS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决跨域——前端代理</title>
    <link href="/2024/01/28/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E2%80%94%E2%80%94%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%90%86/"/>
    <url>/2024/01/28/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E2%80%94%E2%80%94%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>仅能在开发环境下配合 webpack、vite、rollup 等前端构建打包工具使用。</p><p>注意：生产环境需要配合 nginx 代理</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">前端</span> <span class="hljs-number">5173</span><span class="hljs-string">端口</span><br><span class="hljs-string">后端</span> <span class="hljs-number">3000</span><span class="hljs-string">端口</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>跨域的四种解决办法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// 2.build-up tools proxy</span></span><br><span class="language-javascript">      <span class="hljs-comment">// fetch(&#x27;http://localhost:5173/api/json&#x27;)</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 本地</span></span><br><span class="language-javascript">      <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/json&#x27;</span>)</span><br><span class="language-javascript">        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())</span><br><span class="language-javascript">        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000/api&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>),<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>CORS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer network</tag>
      
      <tag>CORS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器同源策略和跨域限制</title>
    <link href="/2024/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%E9%99%90%E5%88%B6/"/>
    <url>/2024/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="URL-简介"><a href="#URL-简介" class="headerlink" title="URL 简介"></a>URL 简介</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL">https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL</a></p><p>URL 由<strong>协议（通常都是 HTTP 协议或是 HTTP 协议的安全版，即 HTTPS）、服务器地址（可以是 IPv4 IPv6 地址，也可以是域名）和端口</strong>三个必须部分，以及一些非必需选项共同组成。</p><p><img src="/img/computer_network/CORS/mdn-url-all.png" alt="mdn-url-all"></p><h1 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h1><p>如果两个页面的<strong>协议，域名和端口</strong>都相同，则两个页面具有相同的源。</p><h1 id="浏览器的同源策略（桌面端通信没有同源策略限制）"><a href="#浏览器的同源策略（桌面端通信没有同源策略限制）" class="headerlink" title="浏览器的同源策略（桌面端通信没有同源策略限制）"></a>浏览器的同源策略（桌面端通信没有同源策略限制）</h1><p><strong>同源策略（英文全称 Same origin policy）是浏览器提供的一个安全功能</strong>。</p><p>MDN 官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 通俗的理解：浏览器规定，A 网站的 JavaScript，不允许和非同源的网站 C 之间，进行资源的交互，例如：</p><p>① 无法读取非同源网页的浏览器缓存如 Cookie、LocalStorage 和 IndexedDB</p><p>② 无法接触非同源网页的 DOM</p><p>③ 无法向非同源地址发送 Ajax 请求</p><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>同源指的是两个 URL 的协议、域名、端口一致，反之，则是跨域。</p><p>出现跨域的根本原因：浏览器的同源策略不允许非同源的 URL 之间进行资源的交互。</p><p>网页：<a href="http://www.test.com/index.html">http://www.test.com/index.html</a></p><p>接口：<a href="http://www.api.com/userlist">http://www.api.com/userlist</a></p><p><strong>浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器的 Ajax 引擎拦截，无法被页面获取到！</strong></p><p><img src="/img/computer_network/CORS/browser-origin-strategy.png" alt="browser-origin-strategy"></p><h1 id="浏览器跨域限制的解决方式"><a href="#浏览器跨域限制的解决方式" class="headerlink" title="浏览器跨域限制的解决方式"></a>浏览器跨域限制的解决方式</h1><p>现如今，实现跨域数据请求，有四种解决方案，分别是 JSONP、Proxy、CORS 和 nginx 代理。</p><h3 id="前后端协商-JSONP"><a href="#前后端协商-JSONP" class="headerlink" title="前后端协商 JSONP"></a>前后端协商 JSONP</h3><p>出现的早，兼容性好（兼容低版本 IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。 缺点是<strong>只支持 GET 请求</strong>，不支持 POST 请求。</p><h3 id="前端解决——前端代理"><a href="#前端解决——前端代理" class="headerlink" title="前端解决——前端代理"></a>前端解决——前端代理</h3><p>仅能在开发环境下配合 webpack、vite、rollup 等前端构建打包工具使用。注意：生产环境需要配合 nginx 代理</p><h3 id="后端解决——CORS"><a href="#后端解决——CORS" class="headerlink" title="后端解决——CORS"></a>后端解决——CORS</h3><p>出现的较晚，它是 W3C 标准，<strong>属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容 某些低版本的浏览器</strong>。有安全请求、非安全请求和携带凭据的请求三种</p><h3 id="运维端解决——ngnix-代理"><a href="#运维端解决——ngnix-代理" class="headerlink" title="运维端解决——ngnix 代理"></a>运维端解决——ngnix 代理</h3><p>在 config 文件中配置 location</p>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>CORS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer network</tag>
      
      <tag>CORS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CDN内容分发网络简介</title>
    <link href="/2024/01/26/CDN/"/>
    <url>/2024/01/26/CDN/</url>
    
    <content type="html"><![CDATA[<h1 id="CDN-Content-Delivery-Network"><a href="#CDN-Content-Delivery-Network" class="headerlink" title="CDN Content Delivery Network"></a>CDN Content Delivery Network</h1><p>CDN 是用来优化网络资源请求的时间的</p><h2 id="优化资源访问速度"><a href="#优化资源访问速度" class="headerlink" title="优化资源访问速度"></a>优化资源访问速度</h2><p>请求资源的速度和资源所在的服务器与我们的地理距离有关，如果距离过远，资源从服务器发送到我们这里所需时间就会很久。</p><p>为了解决这一问题，可以构建一个内容分发网络 CDN，请求资源的时候会优先询问距离我们较近的服务器有没有该资源，如果没有，较近的服务器再向上层层查找，直到找到我们要访问的资源所在的原服务器，获取该资源，缓存到较近的服务器最后再发送给我们。</p><p>这样一来，等到下次再请求该资源的时候，就可以通过 CDN 直接从已经缓存过资源、并且距离非常近的服务器上获取资源，大大减少了网络请求时间</p><h2 id="异地容灾"><a href="#异地容灾" class="headerlink" title="异地容灾"></a>异地容灾</h2><p>使用了 CDN 后，浏览器输入 url 通过 DNS 将域名解析为 IP 的过程会发生变化，第三步不再是查找权威域名服务器，而变成了智能 DNS</p><p><img src="/img/computer_network/CDN/image-20240128190751726.png" alt="image-20240128190751726"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>监控整个网络中浏览器的流量，调度分配每个服务器的任务，使得 CPU 占用率、负载基本均衡</p><p><img src="/img/computer_network/CDN/image-20240128191142254.png" alt="image-20240128191142254"></p>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>CDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器输入url后发生了什么</title>
    <link href="/2024/01/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2024/01/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-DNS-域名解析"><a href="#1-DNS-域名解析" class="headerlink" title="1.DNS 域名解析"></a>1.DNS 域名解析</h1><p><img src="/img/computer_network/after_type_url/DNS.png" alt="DNS"></p><p><img src="/img/computer_network/after_type_url/query-domain-name-server.png" alt="query-domain-name-server"></p><h2 id="2-发送网络请求，三次握手建立-TCP-连接"><a href="#2-发送网络请求，三次握手建立-TCP-连接" class="headerlink" title="2.发送网络请求，三次握手建立 TCP 连接"></a>2.发送网络请求，三次握手建立 TCP 连接</h2><p>历经 OSI 七层网络模型逐步发送网络请求，最重要的是在传输层经过三次握手建立可靠的 TCP 连接，最后在应用层发送 HTTP 请求。</p><p>请求主要分为三部分：<strong>method headers body</strong></p><p>method 方法除了简单的 get post 之外还有遵从 restful 规范的 put delete patch 等方法，需要注意的是 options，是发送 preflight</p><p>预检请求的方法，如果一个 HTTP Request 不存从以下两点安全性要求：</p><ol><li><p>安全的方法：GET POST HEAD</p></li><li><p>安全的 headers：仅允许自定义下列 header：</p><ul><li>Accept</li><li>Accept- Language</li><li>Content-Language</li><li>Content-Type 的值为 application&#x2F;x-www-form-urlencoded，multipart&#x2F;form-data 或 text&#x2F;plain。</li></ul></li></ol><p>浏览器基于安全性考虑就会发送 preflight（预检请求，方法不是 POST&#x2F;GET 等，而是 OPTIONS），通过之后才会发送真正的请求</p><p><img src="/img/computer_network/after_type_url/image-20240202191157031.png" alt="image-20240202191157031"></p><h2 id="3-浏览器的强缓存和协商缓存"><a href="#3-浏览器的强缓存和协商缓存" class="headerlink" title="3.浏览器的强缓存和协商缓存"></a>3.浏览器的强缓存和协商缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>第一次成功发送请求并且成功获取响应之后，如果后台设置了强缓存，会强制浏览器将服务端提供的资源缓存在硬盘或者内存中。</strong></p><p>下次刷新浏览器发送同样的请求，如果没有超出浏览器缓存的时间限制，浏览器会直接返回请求内容，不会再通知服务端、请求服务端。</p><p>如果超出了 max-age 或 expires 规定的时间，服务器强缓存的资源就过期了。</p><p>max-age 的优先级高于 expires，前者是 HTTP1.1 支持，后者 HTTP1.0 支持。</p><p><img src="/img/computer_network/after_type_url/strong-cache.png" alt="strong-cache"></p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当服务端发现资源的最后修改时间 Last-Modified 和 If-Modified-Since 值相等，代表资源从该时间之后从未改变过，返回<strong>304 状态码和空响应体</strong>，浏览器拿到后知道原本可能过期的强缓存内容还可以继续使用。</p><p>如果值不相等，说明资源改变了，就会返回 200 状态码，响应体内为最新资源</p><h2 id="4-四次挥手断开-TCP-连接"><a href="#4-四次挥手断开-TCP-连接" class="headerlink" title="4.四次挥手断开 TCP 连接"></a>4.四次挥手断开 TCP 连接</h2><p><img src="/img/computer_network/after_type_url/image-20240202191126170.png" alt="image-20240202191126170"></p><h2 id="5-HTML-页面开始渲染"><a href="#5-HTML-页面开始渲染" class="headerlink" title="5.HTML 页面开始渲染"></a>5.HTML 页面开始渲染</h2><h3 id="绘制-DOM-树"><a href="#绘制-DOM-树" class="headerlink" title="绘制 DOM 树"></a>绘制 DOM 树</h3><p>HTML 解析器将超文本和标签解析成 DOM 树，绘制成一棵<strong>抽象语法树 AST</strong></p><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>渲染引擎将 CSS 样式表转换成浏览器可以理解的 style sheets，计算出 DOM 节点的样式</p><p>CSS 样式来源主要有三种：内嵌、内联、外联</p><p>CSS 文本中诸如 2em、blue 等无法直接被渲染引擎理解的内容会先经过属性值标准化的过程，转化为能被理解的标准值</p><p>然后再处理样式的继承和层叠，这个过程叫做 CSSOM 的构建过程</p><h3 id="回流（Reflow）和大小、宽高相关的一定是回流"><a href="#回流（Reflow）和大小、宽高相关的一定是回流" class="headerlink" title="回流（Reflow）和大小、宽高相关的一定是回流"></a>回流（Reflow）和大小、宽高相关的一定是回流</h3><p>当 render tree 中部分或全部元素的<strong>尺寸、结构或者某些属性</strong>发生改变时，<strong>浏览器重新渲染部分或全部文档的过程被称为回流。</strong></p><p>会导致回流的操作：</p><ul><li>页面首次渲染</li><li>浏览器窗口大小改变</li><li>元素尺寸或位置改变</li><li>元素字体大小改变</li><li>DOM 元素增删</li><li>激活 CSS 伪类</li></ul><p>一些常用且会导致回流的属性和方法：</p><ul><li>clientWidth clientHeight clientTop clientLeft</li><li>offsetWdith offsetHeight offsetTop offsetLeft</li><li>scrollWidth scrollHeight scrollTop scrollLeft</li><li>getBoundingClientRect</li></ul><h3 id="重绘（Repaint）绘色"><a href="#重绘（Repaint）绘色" class="headerlink" title="重绘（Repaint）绘色"></a>重绘（Repaint）绘色</h3><p>元素的 color、background color 等属性变化时，浏览器会重新绘制</p><h3 id="V8-解析-javascript"><a href="#V8-解析-javascript" class="headerlink" title="V8 解析 javascript"></a>V8 解析 javascript</h3><p>V8 解释器基于 JIT（Justin Runtime）实现</p><p><img src="/img/computer_network/after_type_url/image-20240202191101874.png" alt="image-20240202191101874"></p><h4 id="为什么不把-js-代码直接编译成机器码，而是有中间的字节码？"><a href="#为什么不把-js-代码直接编译成机器码，而是有中间的字节码？" class="headerlink" title="为什么不把 js 代码直接编译成机器码，而是有中间的字节码？"></a>为什么不把 js 代码直接编译成机器码，而是有中间的字节码？</h4><p>因为浏览器的运行环境可能不同，比如操作系统、CPU 硬件资源可能不同，为了实现跨平台的兼容通用，JS 代码统一解析成字节码，字节码的解释器和编译器适配各个平台，最终编译成机器码，由浏览器调度硬件资源执行指令</p>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>browser</category>
      
    </categories>
    
    
    <tags>
      
      <tag>browser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP三次握手与四次挥手</title>
    <link href="/2024/01/25/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2024/01/25/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-基础知识"><a href="#TCP-基础知识" class="headerlink" title="TCP 基础知识"></a>TCP 基础知识</h1><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的<strong>传输层通信协议</strong>。</p><p>TCP 连接是用于保证可靠性和流量控制维护的某些状态信息的组合，包括 Socket、序列 号和窗口大小</p><p>TCP 四元组可以唯一的确定一个连接：源地址、源端口、目的地址、目的端口</p><h1 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>seq（sequence number），通过 sequence initial algorithm 随机生成的<br>ack（acknowledgement number），确认号 ack&#x3D;seq+1<br>ACK（acknowledgement）确定确认号有效<br>SYN（synchronous）发起新连接</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><img src="/img/computer_network/browser-origin/image-20240202191157031.png" alt="image-20240202191157031"></p><p><img src="/img/computer_network/browser-origin/image-20240202191822606.png" alt="image-20240202191822606"></p><h1 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h1><h2 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h2><p>seq（sequence number），通过 sequence initial algorithm 随机生成的<br>ack（acknowledgement number），确认号 ack&#x3D;seq+1<br>ACK（acknowledgement）确定确认号有效<br>SYN（synchronous）发起新连接<br>FIN（FINISH）完成</p><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><p><img src="/img/computer_network/browser-origin/image-20240202191126170.png" alt="image-20240202191126170"></p><p><img src="/img/computer_network/browser-origin/image-20240202191750514.png" alt="image-20240202191750514"></p><h3 id="等待阶段-2"><a href="#等待阶段-2" class="headerlink" title="等待阶段 2"></a>等待阶段 2</h3><p>FIN_WAIT_2 会处理还没有完成的任务，直到所有的任务处理完毕，才会发送第三次挥手</p><h3 id="超时等待状态持续-1-～-4-分钟，存在的原因？"><a href="#超时等待状态持续-1-～-4-分钟，存在的原因？" class="headerlink" title="超时等待状态持续 1 ～ 4 分钟，存在的原因？"></a>超时等待状态持续 1 ～ 4 分钟，存在的原因？</h3><p>这是为了保证服务端收到 ACK 包。</p><p>假设如果没有 2MSL 的等待时间，ACK 包丢失了，那服务端将永远不会断开连接。</p><p>有了 2MSL，如果一旦发生丢包将会进行超时重传，实现可靠连接。</p>]]></content>
    
    
    <categories>
      
      <category>computer network</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mini-react学习总结</title>
    <link href="/2024/01/21/mini-react%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/21/mini-react%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我参与<a href="https://github.com/cuixiaorui">崔大</a>发起的“mini-react 游戏副本”完整课程后的思路总结、技巧收获总结以及心得感悟。</p><p>思路总结重在阐述解决的问题和实现的大致思路，具体代码和详细的工作流程解释可见<a href="https://github.com/hugtyftg/mini-react%E3%80%82">https://github.com/hugtyftg/mini-react。</a></p><p>技巧收获重在分享令我醍醐灌顶的方法和技巧。</p><p>心得感悟重在记录我在整个学习过程中的感受和自我审视。</p><h1 id="mini-react-实现思路总结"><a href="#mini-react-实现思路总结" class="headerlink" title="mini-react 实现思路总结"></a>mini-react 实现思路总结</h1><h2 id="jsx-到-vdom-的转换"><a href="#jsx-到-vdom-的转换" class="headerlink" title="jsx 到 vdom 的转换"></a>jsx 到 vdom 的转换</h2><p>react 中的 jsx 语法本质上是 createElement 的语法糖，在 vite 中，esbuild 自动寻找当前引入的 React 模块中的 createElement 函数，将 jsx 语法用该函数解析为 vdom。</p><p>react 将除了标签本身的所有内容都看作 props，因此，vdom 的基本结构如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">VirtualDOM</span> &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;string&#x27;</span>;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">children</span>: <span class="hljs-title class_">VirtualDOM</span>[] | [];<br>    [<span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>vdom 按照内容可以粗浅分为两类，一种是没有实际文本内容标签构成的元素节点，另一类是现实文本内容的文本节点，因此 createElement 函数要兼容这两种情况。</p><h2 id="vdom-渲染为真实-DOM"><a href="#vdom-渲染为真实-DOM" class="headerlink" title="vdom 渲染为真实 DOM"></a>vdom 渲染为真实 DOM</h2><p>渲染过程可以抽象成 3 个步骤</p><ol><li>创建 dom</li><li>设置 props</li><li>添加 dom</li></ol><p>在每一步内具体考虑实现细节，比如 dom 创建时候要根据 vdom 的 type，props 要分成 children、style 和剩余 props 这三种情况处理</p><h2 id="微任务拆分调度"><a href="#微任务拆分调度" class="headerlink" title="微任务拆分调度"></a>微任务拆分调度</h2><p>对于浏览器中 JS 单线程执行的工作方式而言，一旦 DOM 树过于复杂，就会出现严重的界面渲染卡顿。</p><p>为了解决这一问题，我们可以把渲染整棵树这样的宏观庞大任务拆分成多个以渲染单 DOM 为目标的微任务，将微任务塞到浏览器的空闲时间内依次执行，充分利用计算资源。这就意味着要将非线形的 DOM 树形结构转换成一个线性的微任务执行队列，执行完一个任务之后返回下一个任务。因此选用链表，基于每个 vdom 节点创建微任务的执行单元——fiber，采用 child -&gt; sibling -uncle 这种类似树的深度优先前序遍历的顺序将 DOM 树转换成一个 fiber 队列，在浏览器空余时间内不断地执行任务、返回下一个任务直至终结。</p><h2 id="统一提交"><a href="#统一提交" class="headerlink" title="统一提交"></a>统一提交</h2><p>我们拆分出来的微任务会在浏览器的每个空闲时间片内执行，但如果在一个空闲时间片内，当前任务没有完全完成、dom 节点没有彻底创建完毕的时候，空闲时间就已经使用殆尽，任务就此中断。只有过了一段时间、到了下一次出现空闲时间片的时候，才会再次执行上次的遗留任务。这样一来，用户只会看到界面只出现一部分 DOM 而不是完整的 DOM，过了一段时间后才会陆续出现其他 DOM，也就是前端视觉卡顿。</p><p>该问题的本质是浏览器内核在执行任务的过程中具有异步性，以一种不可预知的速度执行每一个任务，因此空闲时间的出现以及对应 callback 的调用也是不可预估、时有时无的。如果在这样的时间内安排视觉呈现的工作，难免会出现断断续续的卡顿渲染，正如 MDN 官方文档对该 api 的注解一样：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E7%A9%BA%E9%97%B2%E5%9B%9E%E8%B0%83"><strong>避免在空闲回调中改变 DOM</strong>。空闲回调执行的时候，当前帧已经结束绘制了，所有布局的更新和计算也已经完成。如果你做的改变影响了布局，你可能会强制停止浏览器并重新计算，而从另一方面来看，这是不必要的。如果你的回调需要改变 DOM，它应该使用 Window.requestAnimationFrame() 来调度它。</a></p><p>因此只需要在这些时间片内进行计算工作，在链表计算处理结束的时候统一提交、执行真实 dom 的挂载即可。</p><h2 id="函数组件的解析和处理"><a href="#函数组件的解析和处理" class="headerlink" title="函数组件的解析和处理"></a>函数组件的解析和处理</h2><p>函数组件本质上是一个函数，执行函数组件的过程就是执行该函数的过程。函数组件没有具体意义，更像是一个需要“打开的盒子”，只有运行函数、打开盒子之后，我们才能得到想要的 dom 元素，所以对于没有盒子包裹的普通组件和有盒子包裹的函数组件在处理时并不相同：</p><p>前者在没有 dom 时候可以创建 dom、设置非 props 的属性、对 children 递归处理，而后者因为自身无实意，只能递归处理 children，并且需要通过<code>[fiber.type(props)]</code>才能得到 children 数组。</p><p>FC fiber 没有创建 dom 这一点为 fiber 任务执行过程中统一提交时挂载 DOM 的逻辑埋下隐患：</p><ol><li>没有 dom 无法挂载</li><li>没有 dom，不能作为 parent 被其他 dom 挂载</li></ol><p>处理方式为：</p><ol><li>有 dom 的 fiber 才会挂载到 parent.dom 上</li><li>parent.dom 为空时一直向上寻找，直到有 dom 为止</li></ol><h2 id="更新-props"><a href="#更新-props" class="headerlink" title="更新 props"></a>更新 props</h2><p>更新 props 意味着创建一棵新的 vdom 树，将新旧节点一一对比，再处理新旧不同的情况（仅仅考虑 dom 树的属性变化）。</p><h3 id="如何在不再次传入-el-和-container-的前提下重建-vdom-树呢？"><a href="#如何在不再次传入-el-和-container-的前提下重建-vdom-树呢？" class="headerlink" title="如何在不再次传入 el 和 container 的前提下重建 vdom 树呢？"></a>如何在不再次传入 el 和 container 的前提下重建 vdom 树呢？</h3><p>显而易见，在 render 的统一提交阶段结束之后保存 root 即可。</p><h3 id="如何对比新旧节点？"><a href="#如何对比新旧节点？" class="headerlink" title="如何对比新旧节点？"></a>如何对比新旧节点？</h3><p>之前保存的 root 实际上也是旧 DOM 的 root，因此在构建新 vdom 树、构建新 fiber 微任务队列的时候，同样递归遍历旧的 vdom 树、旧的 fiber 任务队列，通过 alternate 指针将新旧节点联系起来即可（这里考虑的新旧 vdom 树没有节点的变化，仅仅是属性的变化）。</p><p>并且可以在递归处理 children 的时候，根据 fiber.alternate.child 是否为空判断当前是初始化渲染阶段还是更新阶段，并分别给创建出来的 fiber 添加 placement 或 update 的 effectTag 标记，方便 diff props 处理。</p><p><img src="/img/react/mini-react/09-alternate-vdom-tree.png" alt="Alt text"></p><p><img src="/img/react/mini-react/09-alternate-linkedlist.png" alt="Alt text"></p><h3 id="diff-props"><a href="#diff-props" class="headerlink" title="diff props"></a>diff props</h3><p>在边创建新 fiber 边构建 alternate 的过程中，对比 props 会出现三种情况：</p><ol><li>old 有 new 没有 删除</li><li>new 有 old 没有 添加</li><li>new 有 old 有 值不同 更新</li></ol><p>后两种情况可以何必为一种：new 有 old 有，值不同，更新（old 没有改 prop 的话，取值结果是 undefined）。这三种情况通过分别遍历一次新旧 props 即可完成</p><p>在统一提交阶段已经执行了 dom 的挂载，同理，diff props 也应该在 commit 阶段执行。根据 fiber.effectTag，如果 placement 则说明是初始化渲染阶段，应该执行挂载 dom 的任务；如果是 update 说明是更新阶段，更新 props 即可。</p><h2 id="性能优化——更新-props-应该“指哪打哪”而非“从头再来”"><a href="#性能优化——更新-props-应该“指哪打哪”而非“从头再来”" class="headerlink" title="性能优化——更新 props 应该“指哪打哪”而非“从头再来”"></a>性能优化——更新 props 应该“指哪打哪”而非“从头再来”</h2><p>当前的更新逻辑是根据保存的 root 再重新创建一次树，但是就算某一个子组件没有更新（没有使用其他组件传来的、会发生变化的 prop，并且自身确实也没有更新），对应的子树还是会重新创建。最终某个子组件的更新引起了整个 app 的重新执行，造成巨大的计算资源浪费。</p><p>因此在更新时应该重新构建的仅仅是发生变化的函数组件所对应的子树，<strong>起点为 FC fiber，终点为 FC 的最后一个节点，也就是 FC fiber 的 sibling</strong>。</p><h3 id="起点是通过闭包保存的-FC-fiber"><a href="#起点是通过闭包保存的-FC-fiber" class="headerlink" title="起点是通过闭包保存的 FC fiber"></a>起点是通过闭包保存的 FC fiber</h3><p>正是由于函数组件具有需要执行的特点，我们可以将更新的粒度缩小到每个 FC，在 fiber 微任务队列执行到当前 FC 所在的 fiber 时（进入 handleFunctionComponent 时），可以使用闭包获取当前组件的 fiber，以便作为下一次使用（也就是更新时）的起点。</p><h3 id="结束点无疑是更新起点-FC-fiber-sibling"><a href="#结束点无疑是更新起点-FC-fiber-sibling" class="headerlink" title="结束点无疑是更新起点 FC fiber.sibling"></a>结束点无疑是更新起点 FC fiber.sibling</h3><p>在兄弟存在的情况下，如果下一个要执行的 fiber 就是兄弟，那么应该立即停止更新，将 nextWorkOfUnit 设置为 undefined 即可终止；如果兄弟不存在，nextWorkOfUnit 也会是 undefined，也会终止。</p><h2 id="更新-children"><a href="#更新-children" class="headerlink" title="更新 children"></a>更新 children</h2><p>上面的更新只考虑了新旧 dom 树没有 dom 增删变化、只有除 children 外的 props 的变化的情况，涉及到 children 的变化可能有两种情况：</p><ol><li>children 节点总数没有变化，新旧 fiber 队列等长（比如少了一个 div，多了一个 p）</li><li>children 节点总数发生变化，新旧 fiber 队列不等长（最常见）</li></ol><h3 id="新旧-fiber-队列等长度"><a href="#新旧-fiber-队列等长度" class="headerlink" title="新旧 fiber 队列等长度"></a>新旧 fiber 队列等长度</h3><p><img src="/img/react/mini-react/equal-length-children.png" alt="Alt text"></p><p>按照原先的逻辑，如果监测到新旧节点 type 不同的时候，认为当前处在初始更新阶段，因此添加新节点，而没有删除旧节点。这样潦草的判断在哪里自相矛盾呢？</p><p>对了，如果真的认为是初始化更新，oldFiberChild 就应该为空值，但是显然并不为空值。所以可以在新旧节点不同内再根据 oldFiberChild 是否为空，判断当前是真的 placement，还是有 dom 变化的 update。对于前者，现在的统一提交处理已经足够了，对于后者，统一提交前还需要删除旧节点。</p><p>这个功能的实现过程是螺旋上升的，具体可见<a href="#开发三驾马车之一按图索骥实现基础功能">开发三驾马车</a>中的叙述</p><h3 id="新旧-fiber-队列不等长度"><a href="#新旧-fiber-队列不等长度" class="headerlink" title="新旧 fiber 队列不等长度"></a>新旧 fiber 队列不等长度</h3><p><img src="/img/react/mini-react/unequal-children.png" alt="Alt text"></p><p><img src="/img/react/mini-react/unequal-length-linked-list.png" alt="Alt text"></p><p>forEach 遍历新 vdom 树的时候 oldFiberChild 也会更新（重新指向 oldFiberChild.sibling）</p><p>如果新旧子树相同，forEach 结束时，oldFiberChild.sibling 为 undefined，oldFiberChild 被更改为 undefined。</p><p>但是如果 oldFiberChild 仍不为 undefined，说明新旧子树并不相同，多余的子树需要在统一提交阶段被删除。</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initial</span>) &#123;<br>  <span class="hljs-comment">// state</span><br>  <span class="hljs-keyword">let</span> stateHook = &#123;<br>    <span class="hljs-attr">state</span>: initial,<br>  &#125;;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">action</span>) &#123;<br>    <span class="hljs-comment">// 修改state</span><br>    stateHook.<span class="hljs-property">state</span> = <span class="hljs-title function_">action</span>(stateHook.<span class="hljs-property">state</span>);<br>    <span class="hljs-comment">// 给wipRoot重新赋值，推动requestIdleCallback(workLoop)重新生成一棵DOM树，从而更新视图</span><br>    <span class="hljs-comment">// currentFiber为微任务队列执行到这个FC fiber时通过wipFiber获取到的闭包</span><br>    wipRoot = &#123;<br>      ...currentFiber,<br>      <span class="hljs-attr">alternate</span>: currentFiber,<br>    &#125;;<br>    nextWorkOfUnit = wipRoot;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [stateHook.<span class="hljs-property">state</span>, setState];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-action-为函数的-useState"><a href="#实现-action-为函数的-useState" class="headerlink" title="实现 action 为函数的 useState"></a>实现 action 为函数的 useState</h3><p>但是这样做有一个问题，在初始渲染的时候调用了一次 useState，此时的 stateHook 值是 initial，setState 通过闭包拿到的 state 也是 initial。</p><p>在下一次调用 setState、requestIdleCallback 开始工作、更新视图的时候，会再次执行当前的 FC 组件，在再次调用 useState，但是 state 的值还是 initial，因此视图无法更新。</p><p>如果想要视图更新，需要获取到当前 FC 的 fiber 在上一个时间片中的 state 值，据此更新视图</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initial</span>) &#123;<br>  <span class="hljs-comment">// 使用闭包暂时存储这个useState所在的FC的fiber</span><br>  <span class="hljs-keyword">let</span> currentFiber = wipFiber;<br>  <span class="hljs-comment">// 通过alternate指针将两个闭包里面的fiber联系起来。</span><br>  <span class="hljs-keyword">let</span> oldFiberHook = currentFiber.<span class="hljs-property">alternate</span>?.<span class="hljs-property">stateHook</span>;<br>  <span class="hljs-keyword">const</span> stateHook = &#123;<br>    <span class="hljs-attr">state</span>: oldFiberHook ? oldFiberHook.<span class="hljs-property">state</span> : initial,<br>  &#125;;<br>  currentFiber.<span class="hljs-property">stateHook</span> = stateHook;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">action</span>) &#123;<br>    <span class="hljs-comment">// 给wipRoot赋值，开启创建新fiber的流程</span><br>    stateHook.<span class="hljs-property">state</span> = <span class="hljs-title function_">action</span>(stateHook.<span class="hljs-property">state</span>);<br>    wipRoot = &#123;<br>      ...currentFiber,<br>      <span class="hljs-attr">alternate</span>: currentFiber,<br>    &#125;;<br>    nextWorkOfUnit = wipRoot;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [stateHook.<span class="hljs-property">state</span>, setState];<br>&#125;<br></code></pre></td></tr></table></figure><p>对于初始化阶段，当 work 执行到 FC 对应的 fiber 的时候，执行 fiber.type(fiber.props)，也就是自上而下地执行了这个 FC 对应的函数。useState 第一次被执行，此时所有 fiber 都没有 alternate，因此 oldFiberHook 为 undefined，stateHook 赋值的时候采用初始值，当前 FC 所对应的老的 fiber 添加了 stateHook 属性，此时的闭包（函数执行期上下文）记作 EC1，产生的 setState 引用的变量也是在 EC1 内</p><p>在某个时刻调用 setState 之后，EC1 闭包中的 state 值被更新，wipRoot 被赋值，workLoop 自动开始执行。当再次执行到这个 FC 时，通过 fiber.type(fiber.props)又运行了一次 useState，这个时候创建出来了 EC2，state 通过 alternate 被更新为 FC fiber 的 EC1 中的值，也就是刚刚触发的 action 的对 state 的更新结果，并将 EC2 中的 state 返回给 FC，FC 中 jsx 引用的 state 也更新为 EC2 中的值。</p><p>EC2 返回的 setState 函数等待下一次调用它的时刻，重复着修改 EC2 state -&gt; 重新构建 fiber 链表 -&gt; 处理 FC -&gt; fiber.type(fiber.props) -&gt; 执行 useState -&gt; 返回 EC3 的 set -&gt; … 循环往复</p><h3 id="一个-FC-存储多个-state"><a href="#一个-FC-存储多个-state" class="headerlink" title="一个 FC 存储多个 state"></a>一个 FC 存储多个 state</h3><p>如果只是用一个变量保存的话，前面的 state 会被后面的 state 覆盖，所以需要使用数组存储一个 FC 内的所有 state。由于一个应用里面有很多个 FC，每个 FC 有很多个 state，第一反应是直接在全局使用一个二维数组保存每个 n FC * m state，但是，每个 FC 想知道的仅仅是它自身在之前的 state，而不关心其他 FC，并且我们已经通过了上面的机制拿到了每个 FC 对应的闭包，所以使用庞大的二维表是完全没有必要的，应该在全局声明 stateHooks 和 stateHookIndex 两个变量，在每个 FC 对应的 fiber 闭包中初始化赋值为[]和 0</p><h3 id="批处理更新"><a href="#批处理更新" class="headerlink" title="批处理更新"></a>批处理更新</h3><p>上面的逻辑其实有一个很怪的点——setState 的时候，拿到了老 EC 闭包中的值，直接同步更新老的值，然后开始重新构建 DOM 树和 fiber 链表，再次进入 FC 函数，在第二次调用 FC 产生的闭包里面再次执行 useState 的时候，从老 EC 里面拿新值，这样非常不合理，为什么不能在新 EC 里面通过老 EC 的旧值算出新值呢，并且这样的同步修改方式在大量 setState 的时候，明明只需要最终更新一次视图，却因为中间产生了若干中间值而进行了多次不必要的更新。</p><p>解决方法：不同步更新，将所有 action 收集起来放到 updaterQueue 里面，在调用 setState 后再次进入 FC 的 useState 闭包时批量调用，调用完成之后才更新视图。视图只更新一次，提高更新效率</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><h3 id="实现基本的-init-之后调用-effect"><a href="#实现基本的-init-之后调用-effect" class="headerlink" title="实现基本的 init 之后调用 effect"></a>实现基本的 init 之后调用 effect</h3><p>useEffect 调用时机是 React 渲染真实 DOM 之后，并且浏览器完成重新绘制之前</p><p>和 useState 类似，给每个 wipFiber 挂载 effectHook，用以保存副作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useEffect</span>(<span class="hljs-params">callback, deps</span>) &#123;<br>  <span class="hljs-keyword">let</span> effectHook = &#123;<br>    callback,<br>    deps,<br>  &#125;;<br>  wipFiber.<span class="hljs-property">effectHook</span> = effectHook;<br>&#125;<br></code></pre></td></tr></table></figure><p>react 渲染完毕真实 DOM 的时机，即 commitRoot 统一提交中 commitWork 执行完毕的时候，递归遍历所有 fiber，调用绑定在它们身上的副作用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitRoot</span>(<span class="hljs-params"></span>) &#123;<br>  deletions.<span class="hljs-title function_">forEach</span>(commitDeletion);<br>  <span class="hljs-title function_">commitWork</span>(wipRoot.<span class="hljs-property">child</span>);<br>  <span class="hljs-comment">// 统一提交之后开启副作用</span><br>  <span class="hljs-title function_">commitEffect</span>();<br>  currentRoot = wipRoot;<br>  <span class="hljs-comment">// 重置当前活动的fiber</span><br>  wipRoot = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 重置需要删除的fiber</span><br>  deletions = [];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监听-deps，初始化和更新的时候执行副作用"><a href="#监听-deps，初始化和更新的时候执行副作用" class="headerlink" title="监听 deps，初始化和更新的时候执行副作用"></a>监听 deps，初始化和更新的时候执行副作用</h3><p>初始化的时候执行所有的 effect，更新的时候需要判断 deps 是否改变，再确定执行什么 effect，涉及到两个问题</p><ol><li>如何区分初始化和更新阶段：wipFiber.alternate 是否有值</li><li>更新阶段如何判断 deps 是否改变：some 比较新旧 deps 确定是否有依赖项变化，若变化则调用 callback</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitEffect</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">fiber</span>) &#123;<br>    <span class="hljs-comment">// 出口</span><br>    <span class="hljs-keyword">if</span> (!fiber) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据是否有alternate判断当前阶段是初始化还是update</span><br>    <span class="hljs-keyword">if</span> (!fiber.<span class="hljs-property">alternate</span>) &#123;<br>      <span class="hljs-comment">// init，直接执行所有的副作用</span><br>      fiber.<span class="hljs-property">effectHook</span>?.<span class="hljs-title function_">callback</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// update，deps发生变化的时候才执行副作用</span><br>      <span class="hljs-comment">// 有的fiber可能没有使用useEffect，没有effectHook属性，所以用可选链</span><br>      <span class="hljs-keyword">const</span> oldEffectHook = fiber.<span class="hljs-property">alternate</span>?.<span class="hljs-property">effectHook</span>;<br>      <span class="hljs-keyword">const</span> curEffectHook = fiber?.<span class="hljs-property">effectHook</span>;<br>      <span class="hljs-comment">// deps数组内的item只要有一项发生变化，则开启副作用</span><br>      <span class="hljs-keyword">const</span> needUpdate = oldEffectHook?.<span class="hljs-property">deps</span>.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">oldDep, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> oldDep !== curEffectHook?.<span class="hljs-property">deps</span>[index];<br>      &#125;);<br>      <span class="hljs-keyword">if</span> (needUpdate) &#123;<br>        curEffectHook.<span class="hljs-title function_">callback</span>();<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">run</span>(fiber.<span class="hljs-property">child</span>);<br>    <span class="hljs-title function_">run</span>(fiber.<span class="hljs-property">sibling</span>);<br>  &#125;<br>  <span class="hljs-title function_">run</span>(wipFiber);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多个副作用"><a href="#多个副作用" class="headerlink" title="多个副作用"></a>多个副作用</h3><p>和 useState 的处理方式相同，也需要在全局定义一个收集所有 effect 的变量 effectHooks。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> effectHooks;<br></code></pre></td></tr></table></figure><p>在进入 FC 的时候 effectHooks 初始化为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 处理函数组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleFunctionComponent</span>(<span class="hljs-params">fiber</span>) &#123;<br>  <span class="hljs-comment">// 存储将来要更新的FC fiber</span><br>  wipFiber = fiber;<br>  <span class="hljs-comment">// 初始化当前fiber在当前闭包中的stateHooks和对应的index</span><br>  stateHookIndex = <span class="hljs-number">0</span>;<br>  stateHooks = [];<br>  <span class="hljs-comment">// 初始化副作用</span><br>  effectHooks = [];<br>  <span class="hljs-keyword">const</span> children = [fiber.<span class="hljs-title function_">type</span>(fiber.<span class="hljs-property">props</span>)];<br>  <span class="hljs-title function_">reconcileChildren</span>(fiber, children);<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用 useEffect 的时候把所有的 callback 和 deps 收集到 wipFiber.effectHooks 里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useEffect</span>(<span class="hljs-params">callback, deps</span>) &#123;<br>  <span class="hljs-keyword">let</span> effectHook = &#123;<br>    callback,<br>    deps,<br>  &#125;;<br>  effectHooks.<span class="hljs-title function_">push</span>(effectHook);<br>  wipFiber.<span class="hljs-property">effectHooks</span> = effectHooks;<br>&#125;<br></code></pre></td></tr></table></figure><p>在统一处理 effectHooks 的时候分情况（init update）遍历处理所有的 effectHook。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 根据是否有alternate判断当前阶段是初始化还是update</span><br><span class="hljs-keyword">if</span> (!fiber.<span class="hljs-property">alternate</span>) &#123;<br>  <span class="hljs-comment">// init，直接执行所有的副作用</span><br>  fiber.<span class="hljs-property">effectHooks</span>?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effectHook</span>) =&gt;</span> &#123;<br>    effectHook?.<span class="hljs-title function_">callback</span>();<br>  &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// update，deps发生变化的时候才执行副作用</span><br>  fiber.<span class="hljs-property">effectHooks</span>?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">hook, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 有的fiber可能没有使用useEffect，没有effectHook属性，所以用可选链</span><br>    <span class="hljs-keyword">const</span> oldEffectHook = fiber.<span class="hljs-property">alternate</span>?.<span class="hljs-property">effectHooks</span>[index];<br>    <span class="hljs-keyword">const</span> curEffectHook = hook;<br>    <span class="hljs-comment">// deps数组内的item只要有一项发生变化，则开启副作用</span><br>    <span class="hljs-keyword">const</span> needUpdate = oldEffectHook?.<span class="hljs-property">deps</span>.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">oldDep, i</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> oldDep !== curEffectHook?.<span class="hljs-property">deps</span>[i];<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (needUpdate) &#123;<br>      curEffectHook.<span class="hljs-title function_">callback</span>();<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h3><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>一个 FC fiber 应该使用数组存储内含的多个 useEffect item，而一个 useEffect item 应该存储其 callback deps 和 cleanup</p><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>effect 的调用结果</p><h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><p>在组件更新、创建完新的之后会先调用上一次调用 effect 产生的旧的 cleanup（minireact 限制，不调用 deps 为空的 cleanup），再调用 effect 产生新的 cleanup 供下次调用</p><h1 id="习得的神技"><a href="#习得的神技" class="headerlink" title="习得的神技"></a>习得的神技</h1><h2 id="画图-debugger-事半功倍"><a href="#画图-debugger-事半功倍" class="headerlink" title="画图+debugger 事半功倍"></a>画图+debugger 事半功倍</h2><p>以往遇到 bug 的时候，我通常采用的方式是直接打断点调试，这是通解也是最慢的解法，但是往往可以发现一些让人捶胸顿足、哭笑不得的非算法错误。</p><p>如果有十足的把握判断 bug 出现的原因和当前的数据结构与算法有关，不妨在调试之前先画图梳理一遍逻辑。</p><p>比如在返回下一个 fiber 的时候，仅仅按照起初的 child -&gt; sibling -uncle 策略在 dom 树层级较深的时候会在某一棵子树末尾报错，画图在脑海中模拟一遍很快就能发现原因——子树层级太深且向上的很多层 parent.sibling 都为空。一旦锁定真正的问题根因，再难的问题也迎刃而解。</p><p><img src="/img/react/mini-react/parent-find-process.png" alt="Alt text"></p><h2 id="迁移扩展知识，“以不变应万变”"><a href="#迁移扩展知识，“以不变应万变”" class="headerlink" title="迁移扩展知识，“以不变应万变”"></a>迁移扩展知识，“以不变应万变”</h2><p>知识和解决问题的思路是可以迁移扩展的，我们在学习的过程中需要刻意头脑风暴，设想一些当前处理的问题还可能发生的场景，或者当前的方案还可以迁移到哪里。</p><p>比如我在该系列课程中最重要的收获有两点：</p><ol><li>非线形的 DOM 树的渲染任务拆分成单个 fiber 构成的线性链表、利用浏览器空余时间执行微任务</li><li>在整个任务执行过程中，利用闭包缓存每个 FC 的 fiber，useState、useEffect 均使用到了该技巧</li></ol><p>迁移扩展：</p><ol><li>DOM 树的渲染和 svg 图元的渲染别无二致，都可以使用这种微任务思想来解决。更推广的场景是对于运行在浏览器上的 CPU 计算密集型任务，都可以拆分任务，利用浏览器空闲时间逐个击破</li><li>任务执行期的闭包缓存相当于在该阶段打断点，如果运行过程中某些变量的中间值是我们在运行结束后仍然需要的，就可以使用闭包方式把这些值“紧握不放”，有需要的时候再随用随取</li></ol><h2 id="开发三驾马车之一——按图索骥实现基础功能"><a href="#开发三驾马车之一——按图索骥实现基础功能" class="headerlink" title="开发三驾马车之一——按图索骥实现基础功能"></a>开发三驾马车之一——按图索骥实现基础功能</h2><p>开发时通常涉及到三个问题：基础的功能需求实现、函数设计和重构。如果这三驾马车并驾齐驱，无疑会把简单的问题复杂化。我们应该将这三件任务拆分然后逐一执行，减小任务的复杂度。</p><p>面对一个新需求，首先思考的仅仅是如何在现有基础上实现最基本的功能，其余的变量命名风格、逻辑抽象封装等可以先不考虑，甚至可以先实现一种最容易想到的情况。比如在实现 children 更新的时候，移除旧的 fiber 对应的 DOM，最简单直接的思路就是让当前的<code>fiber.parent.dom</code>删除<code>fiber.dom</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 基础功能</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitDeletion</span>(<span class="hljs-params">fiber</span>) &#123;<br>  parentFiber.<span class="hljs-property">dom</span>.<span class="hljs-title function_">removeChild</span>(fiber.<span class="hljs-property">dom</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="开发三驾马车之二——普适函数的进阶设计"><a href="#开发三驾马车之二——普适函数的进阶设计" class="headerlink" title="开发三驾马车之二——普适函数的进阶设计"></a>开发三驾马车之二——普适函数的进阶设计</h2><p>在基本功能实现的基础上，我们深入思考往往会发现，基本功能往往会和其他的功能产生联系。</p><p>比如上面实现的 children 更新，考虑到<strong>function component fiber 没有 dom</strong>的特性，在设计通用功能的时候还需要解决两个问题：</p><ol><li>在 fiber 为 FC fiber 时，<code>fiber.dom</code>为空</li><li>在 fiber.parent 为 FC fiber 时，<code>fiber.parent.dom</code>为空</li></ol><p>因此，第一步的普通实现应该以解决这两个问题为目标，进一步迭代设计：</p><ol><li><code>fiber.dom</code>不为空时才执行删除</li><li><code>fiber.parent.dom</code>为空时一直向上寻找有 dom 的祖先</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 进阶设计</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitDeletion</span>(<span class="hljs-params">fiber</span>) &#123;<br>  <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">dom</span>) &#123;<br>    <span class="hljs-comment">// 如果当前fiber是FC child，父fiber没有dom，就一直向上找</span><br>    <span class="hljs-keyword">let</span> parentFiber = fiber.<span class="hljs-property">parent</span>;<br>    <span class="hljs-keyword">while</span> (!parentFiber.<span class="hljs-property">dom</span>) &#123;<br>      parentFiber = parentFiber.<span class="hljs-property">parent</span>;<br>    &#125;<br>    parentFiber.<span class="hljs-property">dom</span>.<span class="hljs-title function_">removeChild</span>(fiber.<span class="hljs-property">dom</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果当前fiber没有dom，说明是FC，删除它的child即可</span><br>    <span class="hljs-title function_">commitDeletion</span>(fiber.<span class="hljs-property">child</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更普适的情况是，前后 fiber 链表不等长，因此进阶设计又可以进一步进阶，直到可以 cover 我们认为的普适场景</p><h2 id="开发三驾马车之三——贯穿开发周期的重构"><a href="#开发三驾马车之三——贯穿开发周期的重构" class="headerlink" title="开发三驾马车之三——贯穿开发周期的重构"></a>开发三驾马车之三——贯穿开发周期的重构</h2><p>重构主要包括以下几个部分：</p><ol><li>变量、函数的重命名；</li><li>代码段的抽象封装，凡是可以用一句明确的话总结的某一段功能代码，都可以抽离封装成一个函数；</li><li>梳理代码执行过程，调整函数的执行位置；</li><li>思考普适场景中 corner case 的解决方法。</li></ol><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>和群里的小伙伴一起一周通关 mini-react 是一件很有意义的事情，自高中毕业以来很少再有这种集体监督打卡任务的机会了。对于我自身而言，打卡和问题讨论的意义并不是其本身（自认为自制力和独立求知欲还可以），而是一群人为了一个目标踏实奋斗的氛围可以让我更有动力，每天的“肉眼可见“的总结思考可以让我真切体会到自己的进步。</p><p>群里有一些大佬的水平非常高，我这么个前端小白的水平实在是相形见绌，但是也不能产生太严重的焦虑情绪，要相信自己未来可期，希望可以快点实习早日毕业，在实际工作中历练自己，期待能“望其项背”的一天。</p><p>谨以此文，总结我一周来的学习成果和心路历程，与诸君共勉。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>mini-react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useState</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useImperativeHandle</title>
    <link href="/2023/06/21/useImperativeHandle/"/>
    <url>/2023/06/21/useImperativeHandle/</url>
    
    <content type="html"><![CDATA[<h3 id="useImperativeHandle-和-ref-转发"><a href="#useImperativeHandle-和-ref-转发" class="headerlink" title="useImperativeHandle 和 ref 转发"></a>useImperativeHandle 和 ref 转发</h3><p><strong>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值，应当与 forwardRef 一起使用，实现 ref 转发</strong></p><p><strong>我们获取类组件实例后，可以直接调用实例上的方法！</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  submit = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了子组件的submit方法！&quot;</span>);<br>  &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>           ...        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> box = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">current</span>); <span class="hljs-comment">//子组件的实例</span><br>    box.<span class="hljs-property">current</span>.<span class="hljs-title function_">submit</span>();<br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box&#125;</span> /&gt;</span>   </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是直接把 ref 赋值给函数组件，是不被允许的！</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>       ...    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> box = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">current</span>); <span class="hljs-comment">//null // Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</span><br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box&#125;</span> /&gt;</span>   </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>此时我们可以基于 forwardRef 和 useImperativeHandle , 就可以实现父组件调用子组件中的方法！</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;<br>  useEffect,<br>  useRef,<br>  useImperativeHandle,<br>  forwardRef,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">props, ref</span>) &#123;<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">submit</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了子组件的submit方法！&quot;</span>);<br>      &#125;,<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>       ...    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> box = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">current</span>);<br>    box.<span class="hljs-property">current</span>.<span class="hljs-title function_">submit</span>();<br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box&#125;</span> /&gt;</span>   </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useImperativeHandle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useRef深层剖析</title>
    <link href="/2023/06/19/useRef/"/>
    <url>/2023/06/19/useRef/</url>
    
    <content type="html"><![CDATA[<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><h4 id="ref-使用场景"><a href="#ref-使用场景" class="headerlink" title="ref 使用场景"></a>ref 使用场景</h4><p><strong>通常，当你的组件需要“跳出” React 并与外部 API 通信时，你会用到 ref —— 通常是不会影响组件外观的浏览器 API。以下是这些罕见情况中的几个：</strong></p><ul><li><strong>存储 <a href="https://developer.mozilla.org/docs/Web/API/setTimeout">timeout ID</a></strong></li><li><strong>存储和操作 <a href="https://developer.mozilla.org/docs/Web/API/Element">DOM 元素</a>，涉及非受控组件。赋值给标签，目的是获取 DOM 元素；赋值给类组件，目的是获取组件的实例；</strong></li><li><strong>存储不需要被用来计算 JSX 的其他对象。</strong></li></ul><p><strong>如果你的组件需要存储一些值，但不影响渲染逻辑，请选择 ref。</strong></p><h4 id="类组件的三种创建和使用方式"><a href="#类组件的三种创建和使用方式" class="headerlink" title="类组件的三种创建和使用方式"></a>类组件的三种创建和使用方式</h4><h5 id="方式一——字符串形式的-ref（过时了，未来版本可能移除，开发时不推荐使用，效率低）"><a href="#方式一——字符串形式的-ref（过时了，未来版本可能移除，开发时不推荐使用，效率低）" class="headerlink" title="方式一——字符串形式的 ref（过时了，未来版本可能移除，开发时不推荐使用，效率低）"></a>方式一——字符串形式的 ref（<strong>过时了，未来版本可能移除，开发时不推荐使用，效率低</strong>）</h5><p><strong>通过 <code>this.refs</code>访问</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">ref</span>=&quot;input1&quot;/&gt;<br></code></pre></td></tr></table></figure><h5 id="方式二——回调形式的-ref"><a href="#方式二——回调形式的-ref" class="headerlink" title="方式二——回调形式的 ref"></a>方式二——回调形式的 ref</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">React帮我们调用回调函数，并且将当前的DOM节点传入回调函数<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;input<br>  ref=&#123;<span class="hljs-function">(<span class="hljs-params">currentNode</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = currentNode;<br>  &#125;&#125;<br>/&gt;<br><span class="hljs-comment">// currentNode是当前所处的节点，也就是这个input</span><br></code></pre></td></tr></table></figure><p><strong>不能通过 <code>this.refs</code>访问，因为这些 ref 都成了实例属性</strong></p><p><strong>React 不会帮你执行未知属性的回调函数</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;input<br>  ref=&#123;<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = c)&#125;<br>  ahh=&#123;<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  &#125;&#125;<br>  type=<span class="hljs-string">&quot;text&quot;</span><br>  placeholder=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span><br>/&gt;<br></code></pre></td></tr></table></figure><p><strong>如果 ref 回调函数是以**<strong>内联函数的形式定义的，在更新过程中它会被执行两次</strong>，第一次传入参数 null，第二次传入参数 DOM 元素。这是因为在每次渲染时创建一个新的实例，所以 React 清空旧的 ref 并设置新的。通过</strong>将 ref 的回调函数定义成 class 的绑定函数<strong>的方式可以避免上述问题，但是</strong>大多数情况下它是无效的（无关紧要）**</p><h5 id="方式三——createRef-创建-ref-容器（最推荐）"><a href="#方式三——createRef-创建-ref-容器（最推荐）" class="headerlink" title="方式三——createRef 创建 ref 容器（最推荐）"></a>方式三——createRef 创建 ref 容器（<strong>最推荐</strong>）</h5><p><em>React.createRef 调用后可以返回一个容器，该容器可以存储被 ref 所标识的节点,该容器是“专人专用”的，多个 ref 的值可以相互独立</em></p><p><strong>ref 是实例的属性，不能通过 this.refs 访问</strong></p><p><strong>this.myRef.current 是当前引用的 DOM，this.myRef.current.value 是当前 DOM 的值</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">myRef</span> <span class="hljs-operator">=</span> React.createRef()<span class="hljs-comment">;</span><br>&lt;input ref<span class="hljs-operator">=</span>&#123;this.myRef&#125; /&gt;<br></code></pre></td></tr></table></figure><h4 id="hooks-组件通过-useRef-创建-ref-对象"><a href="#hooks-组件通过-useRef-创建-ref-对象" class="headerlink" title="hooks 组件通过 useRef 创建 ref 对象"></a>hooks 组件通过 useRef 创建 ref 对象</h4><p><strong>在函数组件中，可以基于</strong> <code>useRef</code>获取 DOM 元素！类似于类组件中的 ：</p><ul><li><strong>ref&#x3D;{x&#x3D;&gt;thix.box&#x3D;x}</strong></li><li><strong>React.createRef</strong></li></ul><p><strong>函数组件中创建 ref 对象的两种方法：</strong></p><ul><li><code>let box1 = useRef(null)</code></li><li><code>let box2 = React.createRef();</code></li></ul><p><strong>注意：</strong></p><p><strong>React.createRef 也是 ref 对象，在类组件和函数组件中都可以使用</strong></p><p><strong>useRef 只能在函数组件中使用，所有的 hooks 函数都只能在函数组件中使用，在类组件中使用会报错</strong></p><p><strong>ref 只能在 DOM 创建之后才能获取 DOM 元素，也就是说在 useLayoutEffect 阶段就可以使用</strong></p><h4 id="createRef-性能比-useRef-差——每次渲染创建新-ref-对象"><a href="#createRef-性能比-useRef-差——每次渲染创建新-ref-对象" class="headerlink" title="createRef 性能比 useRef 差——每次渲染创建新 ref 对象"></a>createRef 性能比 useRef 差——每次渲染创建新 ref 对象</h4><ul><li><strong>createRef 每次渲染都会返回一个新的引用</strong></li><li><strong>而 useRef 每次都会返回相同的引用</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./Demo.less&#x27;</span>;<br><br><span class="hljs-keyword">let</span> prev1,<br>    prev2;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 函数组件中创建ref对象的两种方法</span><br>    <span class="hljs-keyword">let</span> box1 = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>),<br>        box2 = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>    <span class="hljs-keyword">if</span> (!prev1) &#123;<br>        <span class="hljs-comment">// 第一次DEMO执行，把第一次创建的REF对象赋值给变量</span><br>        prev1 = box1;<br>        prev2 = box2;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 第二次DEMO执行，我们验证一下，新创建的REF对象，和之前第一次创建的REF对象，是否一致？</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prev1 === box1); <span class="hljs-comment">//true  useRef再每一次组件更新的时候（函数重新执行），再次执行useRef方法的时候，不会创建新的REF对象了，获取到的还是第一次创建的那个REF对象！！</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prev2 === box2); <span class="hljs-comment">//false createRef在每一次组件更新的时候，都会创建一个全新的REF对象出来，比较浪费性能！！</span><br>        <span class="hljs-comment">// 总结：在类组件中，创建REF对象，我们基于 React.createRef 处理；但是在函数组件中，为了保证性能，我们应该使用专属的 useRef 处理！！</span><br>    &#125;<br><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box1.<span class="hljs-property">current</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box2.<span class="hljs-property">current</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box1&#125;</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box2&#125;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">                setNum(num + 1);</span><br><span class="language-xml">            &#125;&#125;&gt;</span><br><span class="language-xml">            新增</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>总结：在类组件中，创建 Ref 对象，基于 React.createRef 处理；在函数组件中为了保证性能使用 useRef</strong></p><h4 id="ref-的-DOM-用法总结【useRef】"><a href="#ref-的-DOM-用法总结【useRef】" class="headerlink" title="ref 的 DOM 用法总结【useRef】"></a>ref 的 DOM 用法总结【useRef】</h4><ul><li><strong>给元素标签设置 ref，目的：获取对应的 DOM 元素</strong></li><li><strong>给类组件设置 ref，目的：获取当前调用组件创建的实例（后续可以根据实例获取子组件中的相关信息）</strong><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 基于ref获取子组件的实例，这样基于实例，可以调用子组件内部，挂载到实例上的东西</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    state = &#123; x: <span class="hljs-number">1000</span> &#125;;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> &lt;div className=<span class="hljs-string">&quot;child-box&quot;</span>&gt;<br>            &#123;<span class="hljs-keyword">this</span>.state.x&#125;<br>        &lt;/div&gt;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>给函数组件&#x2F;hooks 设置 ref，直接报错：Function components cannot be given refs. Attempts to access this ref wil fail，但是可以配合 React.forwardRef 实现 ref 的转发。目的：获取函数子组件内的某个 DOM 元素</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 基于forwardRef实现ref转发，目的：获取子组件内部的某个元素</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">props, ref</span>) &#123;<br>    <span class="hljs-comment">// console.log(ref); //在DEMO中，调用Child的时候，传递的ref对象「x」</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;child-box&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useRef</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useLayoutEffect深层剖析</title>
    <link href="/2023/06/17/useLayoutEffect/"/>
    <url>/2023/06/17/useLayoutEffect/</url>
    
    <content type="html"><![CDATA[<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>useLayoutEffect 函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后<strong>同步</strong>调用 effect。</p><p>可以使用它来读取 DOM 布局并同步触发重渲染。</p><p>在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p><p>尽可能使用标准的 useLayoutEffect 以避免阻塞视觉更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect, useLayoutEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 再试试useLayoutEffect</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">let</span> random = +<span class="hljs-title class_">String</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()).<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-title function_">setNum</span>(random);<br>    &#125;<br>  &#125;, [num]);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">background:</span> &#x27;<span class="hljs-attr">lightblue</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">WebkitUserSelect:</span> &#x27;<span class="hljs-attr">none</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">      &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setNum(0);</span><br><span class="language-xml">      &#125;&#125;</span><br><span class="language-xml">    &gt;</span><br><span class="language-xml">      &#123;num&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useEffect-和-useLayoutEffect-区别"><a href="#useEffect-和-useLayoutEffect-区别" class="headerlink" title="useEffect 和 useLayoutEffect 区别"></a>useEffect 和 useLayoutEffect 区别</h3><p><strong>useLayoutEffect 会阻塞浏览器渲染真实 DOM【真实 DOM 对象已经创建了】，优先执行 Effect 链表中的 callback；</strong></p><p><strong>useEffect 不会阻塞浏览器渲染真实 DOM，在渲染真实 DOM 的同时，去执行 Effect 链表中的 callback</strong></p><ul><li>它们里面的回调函数<strong>都是放在 effect 链表</strong>中的，但是 useLayoutEffect 设置的 callback 要<strong>优先</strong>于 useEffect 去执行</li><li>在两者设置的 callback 中，<strong>依然可以获取 DOM 元素</strong>「原因：真实 DOM 对象已经创建了，区别只是浏览器是否渲染」</li><li>如果在 callback 函数中又修改了状态值「视图又要更新」<ul><li>useEffect:浏览器肯定是把第一次的真实已经绘制了，再去渲染第二次真实 DOM【频繁切换有闪烁】</li><li>useLayoutEffect:浏览器是把两次真实 DOM 的渲染，<strong>合并在一起渲染</strong>的【频繁切换无闪烁】</li></ul></li></ul><h3 id="视图更新周期："><a href="#视图更新周期：" class="headerlink" title="视图更新周期："></a>视图更新周期：</h3><p><strong>第一步：基于 babel-preset-react-app 把 JSX 编译为 createElement 格式</strong></p><p><strong>第二步：执行 createElement(…)方法，创建出 virtualDOM</strong></p><p><strong>第三步：基于 root.render 方法把 virtualDOM 变为真实 DOM 对象「DOM-DIFF」</strong></p><p><strong>useLayoutEffect 阻塞浏览器绘制：在整个视图渲染更新周期中，创建出真实 DOM 以后直接执行 useLayoutEffect 的 effect 链表中的方法。如果该方法有 setXXX 操作，那么会直接进入下一次更新周期中，而不会执行第四步。因此无论视图更新的过程执行了多少次，界面永远只看到了一次变化，即【频繁切换无闪烁】</strong></p><p><strong>useEffect 不阻塞浏览器绘制：在 React 渲染完真实 DOM 之后、浏览器绘制完毕之前会执行 effect 链表中的方法，同时第四步也会异步执行。如果 effect 链表中的方法有 setXXX 操作，那么会直接进入下一次更新周期中，同时上一次更新周期中的第四步还在执行，浏览器还在重绘。如果在 useEffect 中频繁触发更新，后台会异步运行多个“第四步”，由于浏览器绘制是需要一定时间的，因此对于速度较慢的设备，用户会看到多次重绘之间的“白屏”，即【频繁切换有闪烁】</strong></p><p><strong>第四步：浏览器渲染和绘制真实 DOM 对象</strong></p><p><strong>从视图更新周期可以看出，useLayoutEffect 和 useEffect 都是可以获取真实 DOM 的时机</strong></p><h3 id="官方文档示例参考"><a href="#官方文档示例参考" class="headerlink" title="官方文档示例参考"></a>官方文档示例参考</h3><p><a href="https://react.docschina.org/reference/react/useLayoutEffect#usage">https://react.docschina.org/reference/react/useLayoutEffect#usage</a></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useLayoutEffect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useState深层剖析</title>
    <link href="/2023/06/14/useState/"/>
    <url>/2023/06/14/useState/</url>
    
    <content type="html"><![CDATA[<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>作用：在函数组件中使用状态，修改状态值可让函数组件更新，类似于类组件中的 setState</p><p>语法：</p><p>const [state, setState] &#x3D; useState(initialState);</p><p>返回一个 state，以及更新 state 的函数</p><p>seXXX(value)修改状态值为 value，并通知视图更新。注意，不同于类组件 setState 的部分更新语法，而是直接修改成 value</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setNum</span>(num + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>新增<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>函数组件【Hooks 组件】不是类组件，所以没有实例的概念，调用组件不再是创建类的实例，而是执行函数并产生一个私有上下文而已，所以在函数组件中不涉及 this 的处理</p><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a><strong>设计原理</strong></h3><p><strong>类组件只在初次渲染时创建一个实例，之后的更新都是按照生命流程走，并不是重新创造实例。</strong></p><p><strong>函数组件的每一次渲染或更新是让函数重新执行，也就是 useState 会被重新执行，产生一个全新的私有上下文，内部的代码也重新执行</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数组件每一次渲染/更新，都具备独立的闭包</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">//10</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>新增<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li><p><strong>执行 handle 方法时，由于所用到的 setNum num 都不是当前作用域的私有变量，所以里面会沿着作用域链找到上级上下文里面的 num 和 setNum（闭包）</strong></p></li><li><p><strong>每次更新都重新执行一次内部的代码、都创建一个新的私有上下文如 EC(DEMO2)，涉及的函数需要进行重新构建。这些函数的作用域会沿着函数的作用域链向上查找，找到每一次执行 DEMO 产生的新的闭包</strong></p></li><li><p><strong>每一次执行 DEMO 函数，也会把 useState 重新执行。但是：</strong></p><ul><li><strong>返回的状态：只有第一次设置的初始值会生效，其余以后再执行，获取的状态都是最新的状态，而不是初始值。</strong></li><li><strong>返回的修改状态的方法：每一次都是新的方法函数</strong></li><li><strong>每次运行 useState 返回的结果都用新的 num 和 setNum 变量保存，因此状态和修改状态的方法的地址和之前的都不同，是全新的</strong></li></ul></li></ol><p><img src="/img/react/useState/useState%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.jpg"></p><p>那么它是如何确保每一次获取的是最新状态值，而不是传递的初始值呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 核心原理：闭包</span><br><span class="hljs-keyword">var</span> _state; <span class="hljs-comment">// 创建全局state。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  _state = _state | initialState;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(_state, value)) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>  _state = <span class="hljs-title function_">value</span>(_state) <span class="hljs-comment">// 相当于传入prevalue后，return经过处理得到的新value</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  _state = value<br>  &#125;<br>    <span class="hljs-comment">// 通知视图更新</span><br>    <span class="hljs-comment">//...重新渲染组件</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> [_state, setState]; <span class="hljs-comment">// 数组是新的变量，里面的每项自然也是新的，栈地址也不相同</span><br>&#125;<br><br><span class="hljs-keyword">let</span> [num1, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始时num1=0  setNum=setState 0x001</span><br><span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//=&gt;_state=100 通知视图更新</span><br><span class="hljs-comment">// ---</span><br>再次执行整个函数组件，在执行到useState的时候：<br><span class="hljs-keyword">let</span> [num2, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//由于初次渲染时，全局state被赋值了，不再为undefined，所以不再赋值为initialState</span><br>在内部又产生了一个新的setState，地址和之前不同，使用这次新的闭包作为父级上下文<br>最后返回新的state和新的setState并被声明为新的变量<br>num2=<span class="hljs-number">100</span>  setNum=setState <span class="hljs-number">0x002</span><br></code></pre></td></tr></table></figure><h3 id="setXXX-沿着作用域查找闭包的理解——与同步异步无关"><a href="#setXXX-沿着作用域查找闭包的理解——与同步异步无关" class="headerlink" title="setXXX 沿着作用域查找闭包的理解——与同步异步无关"></a>setXXX 沿着作用域查找闭包的理解——与同步异步无关</h3><p><img src="/img/react/useState/2.png"></p><p><strong>第一个 setTimeout 沿着作用域链找到的闭包里的 num 是初始渲染的 num，和 setNum 后产生的新的闭包（作用域）无关，因此输出 0</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 0</span><br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span>;<br></code></pre></td></tr></table></figure><h3 id="更新多状态"><a href="#更新多状态" class="headerlink" title="更新多状态"></a>更新多状态</h3><h4 id="方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX-不支持类组件-setState-的-partial-state-change"><a href="#方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX-不支持类组件-setState-的-partial-state-change" class="headerlink" title="方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX 不支持类组件 setState 的 partial state change"></a>方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX 不支持类组件 setState 的 partial state change</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-number">20</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// setState(&#123; x: 100 &#125;); //state=&#123;x:100&#125;</span><br>    <span class="hljs-title function_">setState</span>(&#123;<br>      ...state,<br>      <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>    &#125;);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;state.x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;state.y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：不能像类组件的 setState 函数一样，支持部分状态更新！</p><h4 id="方案二：执行多次-useState，把不同状态分开进行管理「推荐方案」——解耦"><a href="#方案二：执行多次-useState，把不同状态分开进行管理「推荐方案」——解耦" class="headerlink" title="方案二：执行多次 useState，把不同状态分开进行管理「推荐方案」——解耦"></a>方案二：执行多次 useState，把不同状态分开进行管理「推荐方案」——解耦</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>),<br>    [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(<span class="hljs-number">100</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新队列机制【updater，异步批处理】——异步和闭包是两码事"><a href="#更新队列机制【updater，异步批处理】——异步和闭包是两码事" class="headerlink" title="更新队列机制【updater，异步批处理】——异步和闭包是两码事"></a>更新队列机制【updater，异步批处理】——异步和闭包是两码事</h3><p>和类组件中的 setState 一样，每次更新状态值，也不是立即更新，而是利用了更新队列 updater 机制来处理</p><p>① 遇到 setState 会立即将其放入到<strong>更新队列</strong>中，此时状态和视图还都未更新</p><p>②<strong>当所有的代码操作结束</strong>，会刷新队列，也就是通知更新队列中的所有任务执行：把<strong>所有放入的 setState 合并在一起执行，只触发一次状态更新和视图更新</strong></p><ul><li><strong>React 18 全部采用批更新</strong></li><li><strong>React 16 中也和 this.setState 一样，只在合成事件&#x2F;生命周期函数中异步，在定时器、手动 DOM 事件绑定等操作中同步</strong></li><li><strong>可以基于 flushSync 刷新渲染队列</strong></li></ul><p><img src="/%60/img/react/useState/image-20230616122123869.png%60" alt="img"></p><h4 id="检验方式一-在-handler-里面修改-state-之后直接-log-❌"><a href="#检验方式一-在-handler-里面修改-state-之后直接-log-❌" class="headerlink" title="检验方式一:在 handler 里面修改 state 之后直接 log ❌"></a>检验方式一:在 handler 里面修改 state 之后直接 log ❌</h4><p><strong>不能在 handler 里面修改 state 之后直接 log，因为这时 log 的变量仍然是上一次闭包中的，无论同步还是异步更新，都只能是上一个闭包中的值</strong></p><p><strong>因此，每次 log 的结果都是上一次的 state</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Demo.less&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>),<br>    [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>),<br>    [z, setZ] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">30</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(x + <span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>    <span class="hljs-comment">// 1.异步批处理：所有的setXXX操作放到更新队列里面，执行完所有操作之后才会一次清空更新队列，因此console.log先执行</span><br>    <span class="hljs-comment">// 2.闭包：由于handle始终拿到的是父级作用域的闭包，也就是更新前的闭包</span><br>    <span class="hljs-title function_">setY</span>(y + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setZ</span>(z + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>y:&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>z:&#123;z&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span>;<br></code></pre></td></tr></table></figure><h4 id="检验方式二：比较输出”验证值的次数“"><a href="#检验方式二：比较输出”验证值的次数“" class="headerlink" title="检验方式二：比较输出”验证值的次数“"></a>检验方式二：比较输出”验证值的次数“</h4><p>若同步更新，那么会顺序输出“render”三次</p><p>若异步更新，则只在最后批处理更新一次，所以只输出一次</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Demo.less&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;RENDER渲染&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>),<br>    [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>),<br>    [z, setZ] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">30</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(x + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setY</span>(y + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setZ</span>(z + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>y:&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>z:&#123;z&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span>;<br></code></pre></td></tr></table></figure><p><strong>只更新了一次，说明是异步执行的，与位置无关</strong></p><p><img src="/img/react/useState/3.png"></p><h4 id="更新队列-flushSync-设置同步操作"><a href="#更新队列-flushSync-设置同步操作" class="headerlink" title="更新队列 flushSync 设置同步操作"></a>更新队列 flushSync 设置同步操作</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">let</span> [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">/* setX(100);</span><br><span class="hljs-comment">        setY(200); */</span><br><br>    <span class="hljs-comment">/* setTimeout(() =&gt; &#123;</span><br><span class="hljs-comment">            setX(100);</span><br><span class="hljs-comment">            setY(200);</span><br><span class="hljs-comment">        &#125;, 1000); */</span><br><br>    <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setX</span>(<span class="hljs-number">100</span>);<br>    &#125;);<br>    <span class="hljs-title function_">setY</span>(<span class="hljs-number">200</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/react/useState/4.png"></p><h4 id="通过-setXXX-传入-prev-跳出闭包"><a href="#通过-setXXX-传入-prev-跳出闭包" class="headerlink" title="通过 setXXX 传入(prev) &#x3D;&gt;跳出闭包"></a>通过 setXXX 传入(prev) &#x3D;&gt;跳出闭包</h4><h4 id="异步操作与闭包函数作用域例题"><a href="#异步操作与闭包函数作用域例题" class="headerlink" title="异步操作与闭包函数作用域例题"></a>异步操作与闭包函数作用域例题</h4><p><img src="/img/react/useState/5.png"></p><p>异步：handle 里面的 10 次 setX 都会放在更新队列里面，然后在其他事情都做完之后，批处理一次更新完毕所有队列中的数据和视图，因此只’RENDER 渲染’一次</p><p>闭包：x 最后的状态值是 11，因为 handle 里面的所有 x 都是在上一级闭包中拿到的，都是 10，因此批处理中 10 个 setX 都是将 x 更新为 11</p><h3 id="setXXX-的两种传参方式"><a href="#setXXX-的两种传参方式" class="headerlink" title="setXXX 的两种传参方式"></a>setXXX 的两种传参方式</h3><h4 id="1-直接传入新对象，不支持-this-setState-的部分更新"><a href="#1-直接传入新对象，不支持-this-setState-的部分更新" class="headerlink" title="1.直接传入新对象，不支持 this.setState 的部分更新"></a>1.直接传入新对象，不支持 this.setState 的部分更新</h4><h4 id="2-函数式更新——配合-for-循环、updater-机制可以实现结果累计、只更新状态和视图一次-setXXX-prev-，可以有效解决-updater-的闭包问题"><a href="#2-函数式更新——配合-for-循环、updater-机制可以实现结果累计、只更新状态和视图一次-setXXX-prev-，可以有效解决-updater-的闭包问题" class="headerlink" title="2.函数式更新——配合 for 循环、updater 机制可以实现结果累计、只更新状态和视图一次 setXXX(prev &#x3D;&gt;)，可以有效解决 updater 的闭包问题"></a>2.函数式更新——配合 for 循环、updater 机制可以实现结果累计、只更新状态和视图一次 setXXX(prev &#x3D;&gt;)，可以有效解决 updater 的闭包问题</h4><p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState；该函数将接收先前的 state，并返回一个更新后的值！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>      <span class="hljs-comment">// 函数式更新</span><br>      <span class="hljs-title function_">setNum</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span>;<br>      &#125;);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 核心原理：闭包</span><br><span class="hljs-keyword">var</span> _state; <span class="hljs-comment">// 创建全局state。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  _state = _state | initialState;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> _state === <span class="hljs-string">&#x27;undefined&#x27;</span>)&#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> initialState === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>          _state = <span class="hljs-title function_">initialState</span>();<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          _state = initialState;<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(_state, value)) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>  _state = <span class="hljs-title function_">value</span>(_state) <span class="hljs-comment">// 相当于传入prevalue后，return经过处理得到的新value</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  _state = value<br>  &#125;<br>    <span class="hljs-comment">// 通知视图更新</span><br>    <span class="hljs-comment">//...重新渲染组件</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> [_state, setState]; <span class="hljs-comment">// 数组是新的变量，里面的每项自然也是新的，栈地址也不相同</span><br>&#125;<br><br><span class="hljs-keyword">let</span> [num1, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始时num1=0  setNum=setState 0x001</span><br><span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//=&gt;_state=100 通知视图更新</span><br><span class="hljs-comment">// ---</span><br>再次执行整个函数组件，在执行到useState的时候：<br><span class="hljs-keyword">let</span> [num2, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//由于初次渲染时，全局state被赋值了，不再为undefined，所以不再赋值为initialState</span><br>在内部又产生了一个新的setState，地址和之前不同，使用这次新的闭包作为父级上下文<br>最后返回新的state和新的setState并被声明为新的变量<br>num2=<span class="hljs-number">100</span>  setNum=setState <span class="hljs-number">0x002</span><br></code></pre></td></tr></table></figure><h3 id="惰性初始-state——复杂的初始化逻辑只执行一次"><a href="#惰性初始-state——复杂的初始化逻辑只执行一次" class="headerlink" title="惰性初始 state——复杂的初始化逻辑只执行一次"></a>惰性初始 state——复杂的初始化逻辑只执行一次</h3><p>如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，<strong>此函数只在初始渲染时被调用，之后更新视图以后，状态值不再是 undefined，所以不会再执行初始的惰性回调</strong>！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; x, y &#125; = props;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：如果将回调里的逻辑写到外面，则一旦视图更新，不管是第一次还是后续更新的时候，这段逻辑都会执行。<strong>即使在更新阶段，num 不再是 undefined，初始值不再生效，这段逻辑依然会执行，浪费资源效率低下</strong></p><img src="/img/react/useState/image-20230616150504612.png" alt="image-20230616150504612" style="zoom:67%;" /><h3 id="useState-性能优化机制——Object-is-类似-PureComponent-的浅比较"><a href="#useState-性能优化机制——Object-is-类似-PureComponent-的浅比较" class="headerlink" title="useState 性能优化机制——Object.is 类似 PureComponent 的浅比较"></a>useState 性能优化机制——Object.is 类似 PureComponent 的浅比较</h3><p>useState 自带了性能优化的机制：</p><ul><li><strong>每一次修改状态值的时候，会拿最新要修改的值和之前的状态值做比较「基于 Object.is 作比较，而不是更严格的&#x3D;&#x3D;&#x3D;。如果前后状态都是 NaN，Object.is 返回 true 不更新状态和视图，&#x3D;&#x3D;&#x3D;返回 false 更新状态和视图」</strong></li><li><strong>如果发现两次的值是一样的，则不会修改状态，也不会让视图更新「可以理解为：类似于 PureComponent，在 shouldComponentUpdate 中做了浅比较和优化，注意函数组件中不可能有 PureComponent」</strong></li></ul><p>调用 State Hook 的更新函数，并传入当前的 state 时，React 将跳过组件的渲染（原因：React 使用 Object.is 比较算法，来比较新老 state；注意不是因为 DOM-DIFF；）！</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;render&quot;</span>);<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setNum(num);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        处理</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 核心原理：闭包</span><br><span class="hljs-keyword">var</span> _state; <span class="hljs-comment">// 创建全局state。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  _state = _state | initialState;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(_state, value)) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>  _state = <span class="hljs-title function_">value</span>(_state) <span class="hljs-comment">// 相当于传入prevalue后，return经过处理得到的新value</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  _state = value<br>  &#125;<br>    <span class="hljs-comment">// 通知视图更新</span><br>    <span class="hljs-comment">//...重新渲染组件</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> [_state, setState]; <span class="hljs-comment">// 数组是新的变量，里面的每项自然也是新的，栈地址也不相同</span><br>&#125;<br><span class="hljs-keyword">let</span> [num1, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始时num1=0  setNum=setState 0x001</span><br><span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//=&gt;_state=100 通知视图更新</span><br><span class="hljs-comment">// ---</span><br>再次执行整个函数组件，在执行到useState的时候：<br><span class="hljs-keyword">let</span> [num2, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//由于初次渲染时，全局state被赋值了，不再为undefined，所以不再赋值为initialState</span><br>在内部又产生了一个新的setState，地址和之前不同，使用这次新的闭包作为父级上下文<br>最后返回新的state和新的setState并被声明为新的变量<br>num2=<span class="hljs-number">100</span>  setNum=setState <span class="hljs-number">0x002</span><br></code></pre></td></tr></table></figure><h4 id="例-1-前后-state-浅比较-true，不更新状态和视图"><a href="#例-1-前后-state-浅比较-true，不更新状态和视图" class="headerlink" title="例 1 前后 state 浅比较 true，不更新状态和视图"></a>例 1 前后 state 浅比较 true，不更新状态和视图</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UseStateDemo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">UseStateDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;RENDER&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(<span class="hljs-number">10</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UseStateDemo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UseStateDemo</span>;<br></code></pre></td></tr></table></figure><p>不更新视图和状态</p><h4 id="例-2-更新多次，最终值-11"><a href="#例-2-更新多次，最终值-11" class="headerlink" title="例 2 更新多次，最终值 11"></a>例 2 更新多次，最终值 11</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UseStateDemo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">UseStateDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;RENDER&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>      <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setX</span>(x + <span class="hljs-number">1</span>);<br>      &#125;);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UseStateDemo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UseStateDemo</span>;<br></code></pre></td></tr></table></figure><p>render 两次（理论上是一次，这里是因为这些操作作用的都是一个闭包中的同一个状态值，在第一次改状态还没改成功之前，其他次操作访问的状态值仍旧是还没改的 10，直到第一次改状态成功，剩余次操作不会再通过 Object.is 的测试。这里 render 次数和浏览器的效率有关，不过绝对不是 10 次 ），最后状态值是 11</p><p><img src="/img/react/useState/6.png"></p><p>在第一次渲染时创造出来顶级的函数作用域，_state 私有属性就是在这个顶级作用域里面的</p><p>点击 handle 之后会执行 10 次同步清空更新队列的操作</p><p>在第一次 flushSync，更新队列里只有一个 setX，立即同步执行，使用的是第一次 Demo 创建出来的 EC 的闭包中的 state，也就是 10。进入 setX，通过了 Object.is 的比较，更新状态和视图，此时最外部的_state 也被更新为 11</p><p>第二次 flushSync，更新队列里只有一个 setX，立即同步执行，使用的也是第一次 Demo 创建出来的 EC 的闭包中的 state（因为这些 flushSync 方法都存在于第一个上下文中），也就是 10。进入 setX，未通过了 Object.is 的比较，因此不更新状态和视图</p><p>第三。。。十轮同样不更新</p><h4 id="例-3-更新-1-次，最终值-20-——函数式更新"><a href="#例-3-更新-1-次，最终值-20-——函数式更新" class="headerlink" title="例 3 更新 1 次，最终值 20 ——函数式更新"></a>例 3 更新 1 次，最终值 20 ——函数式更新</h4><p><img src="/img/react/useState/7.png"></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useState</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react hooks简介</title>
    <link href="/2023/06/01/Hooks%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/06/01/Hooks%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="React-组件回顾"><a href="#React-组件回顾" class="headerlink" title="React 组件回顾"></a>React 组件回顾</h2><h3 id="函数组件特点"><a href="#函数组件特点" class="headerlink" title="函数组件特点"></a>函数组件特点</h3><ul><li>不具备“状态、ref、周期函数”等内容，第一次渲染完毕后，无法基于组件内部的操作来控制其更新，因此称之为静态组件！</li><li>但是具备属性及插槽，父组件可以控制其重新渲染！</li><li>渲染流程简单，渲染速度较快！</li><li>基于 FP（函数式编程）思想设计，提供更细粒度的逻辑组织和复用！</li><li><strong>纯函数组件，无法改状态</strong></li></ul><h3 id="类组件特点"><a href="#类组件特点" class="headerlink" title="类组件特点"></a>类组件特点</h3><ul><li>具备“状态、ref、周期函数、属性、插槽”等内容，可以灵活的控制组件更新，基于钩子函数也可灵活掌控不同阶段处理不同的事情！</li><li>渲染流程繁琐，渲染速度相对较慢！</li><li>基于 OOP（面向对象编程）思想设计，更方便实现继承等！</li></ul><h3 id="React-Hooks-组件"><a href="#React-Hooks-组件" class="headerlink" title="React Hooks 组件"></a>React Hooks 组件</h3><p>就是基于 React 中新提供的 Hook 函数，可以 <code>让函数组件动态化</code>!</p><h2 id="Hook-函数概览"><a href="#Hook-函数概览" class="headerlink" title="Hook 函数概览"></a>Hook 函数概览</h2><p>Hook 是 React 16.8 的新增特性！并且只能运用到函数组件中！<br><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html">https://zh-hans.reactjs.org/docs/hooks-reference.html</a></p><ul><li>基础 Hook<ul><li><code>useState</code> 使用状态管理</li><li><code>useEffect</code> 使用周期函数</li><li><code>useContext</code> 使用上下文信息</li></ul></li><li>额外的 Hook<ul><li><code>useReducer</code> useState 的替代方案，借鉴 redux 处理思想，管理更复杂的状态和逻辑</li><li><code>useCallback</code> 构建缓存优化方案</li><li><code>useMemo</code> 构建缓存优化方案</li><li><code>useRef</code> 使用 ref 获取 DOM</li><li><code>useImperativeHandle</code> 配合 forwardRef（ref 转发）一起使用</li><li><code>useLayoutEffect</code> 与 useEffect 相同，但会在所有的 DOM 变更之后同步调用 effect</li><li>…</li></ul></li><li>自定义 Hook</li><li>……</li></ul>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
