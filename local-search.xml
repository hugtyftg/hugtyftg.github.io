<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>useState深层剖析</title>
    <link href="/2023/12/14/useState%E6%B7%B1%E5%B1%82%E5%89%96%E6%9E%90/"/>
    <url>/2023/12/14/useState%E6%B7%B1%E5%B1%82%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>作用：在函数组件中使用状态，修改状态值可让函数组件更新，类似于类组件中的 setState</p><p>语法：</p><p>const [state, setState] &#x3D; useState(initialState);</p><p>返回一个 state，以及更新 state 的函数</p><p>seXXX(value)修改状态值为 value，并通知视图更新。注意，不同于类组件 setState 的部分更新语法，而是直接修改成 value</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setNum</span>(num + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>新增<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>函数组件【Hooks 组件】不是类组件，所以没有实例的概念，调用组件不再是创建类的实例，而是执行函数并产生一个私有上下文而已，所以在函数组件中不涉及 this 的处理</p><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a><strong>设计原理</strong></h3><p><strong>类组件只在初次渲染时创建一个实例，之后的更新都是按照生命流程走，并不是重新创造实例。</strong></p><p><strong>函数组件的每一次渲染或更新是让函数重新执行，也就是 useState 会被重新执行，产生一个全新的私有上下文，内部的代码也重新执行</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数组件每一次渲染/更新，都具备独立的闭包</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">//10</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>新增<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li><p><strong>执行 handle 方法时，由于所用到的 setNum num 都不是当前作用域的私有变量，所以里面会沿着作用域链找到上级上下文里面的 num 和 setNum（闭包）</strong></p></li><li><p><strong>每次更新都重新执行一次内部的代码、都创建一个新的私有上下文如 EC(DEMO2)，涉及的函数需要进行重新构建。这些函数的作用域会沿着函数的作用域链向上查找，找到每一次执行 DEMO 产生的新的闭包</strong></p></li><li><p><strong>每一次执行 DEMO 函数，也会把 useState 重新执行。但是：</strong></p><ul><li><strong>返回的状态：只有第一次设置的初始值会生效，其余以后再执行，获取的状态都是最新的状态，而不是初始值。</strong></li><li><strong>返回的修改状态的方法：每一次都是新的方法函数</strong></li><li><strong>每次运行 useState 返回的结果都用新的 num 和 setNum 变量保存，因此状态和修改状态的方法的地址和之前的都不同，是全新的</strong></li></ul></li></ol><p><img src="/.io//useState%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.jpg"></p><p>那么它是如何确保每一次获取的是最新状态值，而不是传递的初始值呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 核心原理：闭包</span><br><span class="hljs-keyword">var</span> _state; <span class="hljs-comment">// 创建全局state。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  _state = _state | initialState;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(_state, value)) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>  _state = <span class="hljs-title function_">value</span>(_state) <span class="hljs-comment">// 相当于传入prevalue后，return经过处理得到的新value</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  _state = value<br>  &#125;<br>    <span class="hljs-comment">// 通知视图更新</span><br>    <span class="hljs-comment">//...重新渲染组件</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> [_state, setState]; <span class="hljs-comment">// 数组是新的变量，里面的每项自然也是新的，栈地址也不相同</span><br>&#125;<br><br><span class="hljs-keyword">let</span> [num1, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始时num1=0  setNum=setState 0x001</span><br><span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//=&gt;_state=100 通知视图更新</span><br><span class="hljs-comment">// ---</span><br>再次执行整个函数组件，在执行到useState的时候：<br><span class="hljs-keyword">let</span> [num2, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//由于初次渲染时，全局state被赋值了，不再为undefined，所以不再赋值为initialState</span><br>在内部又产生了一个新的setState，地址和之前不同，使用这次新的闭包作为父级上下文<br>最后返回新的state和新的setState并被声明为新的变量<br>num2=<span class="hljs-number">100</span>  setNum=setState <span class="hljs-number">0x002</span><br></code></pre></td></tr></table></figure><h3 id="setXXX-沿着作用域查找闭包的理解——与同步异步无关"><a href="#setXXX-沿着作用域查找闭包的理解——与同步异步无关" class="headerlink" title="setXXX 沿着作用域查找闭包的理解——与同步异步无关"></a>setXXX 沿着作用域查找闭包的理解——与同步异步无关</h3><p><img src="/.io//2.png"></p><p><strong>第一个 setTimeout 沿着作用域链找到的闭包里的 num 是初始渲染的 num，和 setNum 后产生的新的闭包（作用域）无关，因此输出 0</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 0</span><br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span>;<br></code></pre></td></tr></table></figure><h3 id="更新多状态"><a href="#更新多状态" class="headerlink" title="更新多状态"></a>更新多状态</h3><h4 id="方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX-不支持类组件-setState-的-partial-state-change"><a href="#方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX-不支持类组件-setState-的-partial-state-change" class="headerlink" title="方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX 不支持类组件 setState 的 partial state change"></a>方案一：类似于类组件中一样，让状态值是一个对象（包含需要的全部状态），每一次只修改其中的一个状态值——setXXX 不支持类组件 setState 的 partial state change</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-number">20</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// setState(&#123; x: 100 &#125;); //state=&#123;x:100&#125;</span><br>    <span class="hljs-title function_">setState</span>(&#123;<br>      ...state,<br>      <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>    &#125;);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;state.x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;state.y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：不能像类组件的 setState 函数一样，支持部分状态更新！</p><h4 id="方案二：执行多次-useState，把不同状态分开进行管理「推荐方案」——解耦"><a href="#方案二：执行多次-useState，把不同状态分开进行管理「推荐方案」——解耦" class="headerlink" title="方案二：执行多次 useState，把不同状态分开进行管理「推荐方案」——解耦"></a>方案二：执行多次 useState，把不同状态分开进行管理「推荐方案」——解耦</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>),<br>    [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(<span class="hljs-number">100</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新队列机制【updater，异步批处理】——异步和闭包是两码事"><a href="#更新队列机制【updater，异步批处理】——异步和闭包是两码事" class="headerlink" title="更新队列机制【updater，异步批处理】——异步和闭包是两码事"></a>更新队列机制【updater，异步批处理】——异步和闭包是两码事</h3><p>和类组件中的 setState 一样，每次更新状态值，也不是立即更新，而是利用了更新队列 updater 机制来处理</p><p>① 遇到 setState 会立即将其放入到<strong>更新队列</strong>中，此时状态和视图还都未更新</p><p>②<strong>当所有的代码操作结束</strong>，会刷新队列，也就是通知更新队列中的所有任务执行：把<strong>所有放入的 setState 合并在一起执行，只触发一次状态更新和视图更新</strong></p><ul><li><p><strong>React 18 全部采用批更新</strong></p></li><li><p><strong>React 16 中也和 this.setState 一样，只在合成事件&#x2F;生命周期函数中异步，在定时器、手动 DOM 事件绑定等操作中同步</strong></p><p><code>&lt;img src=&quot;useState.assets/image-20230616122123869.png&quot; alt=&quot;image-20230616122123869&quot; style=&quot;zoom:50%;&quot; /&gt;</code></p></li><li><p><strong>可以基于 flushSync 刷新渲染队列</strong></p></li></ul><h4 id="检验方式一-在-handler-里面修改-state-之后直接-log-❌"><a href="#检验方式一-在-handler-里面修改-state-之后直接-log-❌" class="headerlink" title="检验方式一:在 handler 里面修改 state 之后直接 log ❌"></a>检验方式一:在 handler 里面修改 state 之后直接 log ❌</h4><p><strong>不能在 handler 里面修改 state 之后直接 log，因为这时 log 的变量仍然是上一次闭包中的，无论同步还是异步更新，都只能是上一个闭包中的值</strong></p><p><strong>因此，每次 log 的结果都是上一次的 state</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Demo.less&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>),<br>    [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>),<br>    [z, setZ] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">30</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(x + <span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>    <span class="hljs-comment">// 1.异步批处理：所有的setXXX操作放到更新队列里面，执行完所有操作之后才会一次清空更新队列，因此console.log先执行</span><br>    <span class="hljs-comment">// 2.闭包：由于handle始终拿到的是父级作用域的闭包，也就是更新前的闭包</span><br>    <span class="hljs-title function_">setY</span>(y + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setZ</span>(z + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>y:&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>z:&#123;z&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span>;<br></code></pre></td></tr></table></figure><h4 id="检验方式二：比较输出”验证值的次数“"><a href="#检验方式二：比较输出”验证值的次数“" class="headerlink" title="检验方式二：比较输出”验证值的次数“"></a>检验方式二：比较输出”验证值的次数“</h4><p>若同步更新，那么会顺序输出“render”三次</p><p>若异步更新，则只在最后批处理更新一次，所以只输出一次</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Demo.less&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;RENDER渲染&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>),<br>    [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>),<br>    [z, setZ] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">30</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(x + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setY</span>(y + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setZ</span>(z + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>y:&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>z:&#123;z&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span>;<br></code></pre></td></tr></table></figure><p><strong>只更新了一次，说明是异步执行的，与位置无关</strong></p><p><img src="/.io//3.png"></p><h4 id="更新队列-flushSync-设置同步操作"><a href="#更新队列-flushSync-设置同步操作" class="headerlink" title="更新队列 flushSync 设置同步操作"></a>更新队列 flushSync 设置同步操作</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">let</span> [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">20</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">/* setX(100);</span><br><span class="hljs-comment">        setY(200); */</span><br><br>    <span class="hljs-comment">/* setTimeout(() =&gt; &#123;</span><br><span class="hljs-comment">            setX(100);</span><br><span class="hljs-comment">            setY(200);</span><br><span class="hljs-comment">        &#125;, 1000); */</span><br><br>    <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setX</span>(<span class="hljs-number">100</span>);<br>    &#125;);<br>    <span class="hljs-title function_">setY</span>(<span class="hljs-number">200</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;y&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/.io//4.png"></p><h4 id="通过-setXXX-传入-prev-跳出闭包"><a href="#通过-setXXX-传入-prev-跳出闭包" class="headerlink" title="通过 setXXX 传入(prev) &#x3D;&gt;跳出闭包"></a>通过 setXXX 传入(prev) &#x3D;&gt;跳出闭包</h4><h4 id="异步操作与闭包函数作用域例题"><a href="#异步操作与闭包函数作用域例题" class="headerlink" title="异步操作与闭包函数作用域例题"></a>异步操作与闭包函数作用域例题</h4><p><img src="/.io//5.png"></p><p>异步：handle 里面的 10 次 setX 都会放在更新队列里面，然后在其他事情都做完之后，批处理一次更新完毕所有队列中的数据和视图，因此只’RENDER 渲染’一次</p><p>闭包：x 最后的状态值是 11，因为 handle 里面的所有 x 都是在上一级闭包中拿到的，都是 10，因此批处理中 10 个 setX 都是将 x 更新为 11</p><h3 id="setXXX-的两种传参方式"><a href="#setXXX-的两种传参方式" class="headerlink" title="setXXX 的两种传参方式"></a>setXXX 的两种传参方式</h3><h4 id="1-直接传入新对象，不支持-this-setState-的部分更新"><a href="#1-直接传入新对象，不支持-this-setState-的部分更新" class="headerlink" title="1.直接传入新对象，不支持 this.setState 的部分更新"></a>1.直接传入新对象，不支持 this.setState 的部分更新</h4><h4 id="2-函数式更新——配合-for-循环、updater-机制可以实现结果累计、只更新状态和视图一次-setXXX-prev-，可以有效解决-updater-的闭包问题"><a href="#2-函数式更新——配合-for-循环、updater-机制可以实现结果累计、只更新状态和视图一次-setXXX-prev-，可以有效解决-updater-的闭包问题" class="headerlink" title="2.函数式更新——配合 for 循环、updater 机制可以实现结果累计、只更新状态和视图一次 setXXX(prev &#x3D;&gt;)，可以有效解决 updater 的闭包问题"></a>2.函数式更新——配合 for 循环、updater 机制可以实现结果累计、只更新状态和视图一次 setXXX(prev &#x3D;&gt;)，可以有效解决 updater 的闭包问题</h4><p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState；该函数将接收先前的 state，并返回一个更新后的值！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>      <span class="hljs-comment">// 函数式更新</span><br>      <span class="hljs-title function_">setNum</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span>;<br>      &#125;);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handler&#125;</span>&gt;</span>处理<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 核心原理：闭包</span><br><span class="hljs-keyword">var</span> _state; <span class="hljs-comment">// 创建全局state。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  _state = _state | initialState;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> _state === <span class="hljs-string">&#x27;undefined&#x27;</span>)&#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> initialState === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>          _state = <span class="hljs-title function_">initialState</span>();<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          _state = initialState;<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(_state, value)) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>  _state = <span class="hljs-title function_">value</span>(_state) <span class="hljs-comment">// 相当于传入prevalue后，return经过处理得到的新value</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  _state = value<br>  &#125;<br>    <span class="hljs-comment">// 通知视图更新</span><br>    <span class="hljs-comment">//...重新渲染组件</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> [_state, setState]; <span class="hljs-comment">// 数组是新的变量，里面的每项自然也是新的，栈地址也不相同</span><br>&#125;<br><br><span class="hljs-keyword">let</span> [num1, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始时num1=0  setNum=setState 0x001</span><br><span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//=&gt;_state=100 通知视图更新</span><br><span class="hljs-comment">// ---</span><br>再次执行整个函数组件，在执行到useState的时候：<br><span class="hljs-keyword">let</span> [num2, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//由于初次渲染时，全局state被赋值了，不再为undefined，所以不再赋值为initialState</span><br>在内部又产生了一个新的setState，地址和之前不同，使用这次新的闭包作为父级上下文<br>最后返回新的state和新的setState并被声明为新的变量<br>num2=<span class="hljs-number">100</span>  setNum=setState <span class="hljs-number">0x002</span><br></code></pre></td></tr></table></figure><h3 id="惰性初始-state——复杂的初始化逻辑只执行一次"><a href="#惰性初始-state——复杂的初始化逻辑只执行一次" class="headerlink" title="惰性初始 state——复杂的初始化逻辑只执行一次"></a>惰性初始 state——复杂的初始化逻辑只执行一次</h3><p>如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，<strong>此函数只在初始渲染时被调用，之后更新视图以后，状态值不再是 undefined，所以不会再执行初始的惰性回调</strong>！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; x, y &#125; = props;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：如果将回调里的逻辑写到外面，则一旦视图更新，不管是第一次还是后续更新的时候，这段逻辑都会执行。<strong>即使在更新阶段，num 不再是 undefined，初始值不再生效，这段逻辑依然会执行，浪费资源效率低下</strong></p><img src="/.io//image-20230616150504612.png" alt="image-20230616150504612" style="zoom:67%;"><h3 id="useState-性能优化机制——Object-is-类似-PureComponent-的浅比较"><a href="#useState-性能优化机制——Object-is-类似-PureComponent-的浅比较" class="headerlink" title="useState 性能优化机制——Object.is 类似 PureComponent 的浅比较"></a>useState 性能优化机制——Object.is 类似 PureComponent 的浅比较</h3><p>useState 自带了性能优化的机制：</p><ul><li><strong>每一次修改状态值的时候，会拿最新要修改的值和之前的状态值做比较「基于 Object.is 作比较，而不是更严格的&#x3D;&#x3D;&#x3D;。如果前后状态都是 NaN，Object.is 返回 true 不更新状态和视图，&#x3D;&#x3D;&#x3D;返回 false 更新状态和视图」</strong></li><li><strong>如果发现两次的值是一样的，则不会修改状态，也不会让视图更新「可以理解为：类似于 PureComponent，在 shouldComponentUpdate 中做了浅比较和优化，注意函数组件中不可能有 PureComponent」</strong></li></ul><p>调用 State Hook 的更新函数，并传入当前的 state 时，React 将跳过组件的渲染（原因：React 使用 Object.is 比较算法，来比较新老 state；注意不是因为 DOM-DIFF；）！</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;render&quot;</span>);<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setNum(num);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        处理</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 核心原理：闭包</span><br><span class="hljs-keyword">var</span> _state; <span class="hljs-comment">// 创建全局state。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  _state = _state | initialState;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(_state, value)) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>  _state = <span class="hljs-title function_">value</span>(_state) <span class="hljs-comment">// 相当于传入prevalue后，return经过处理得到的新value</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  _state = value<br>  &#125;<br>    <span class="hljs-comment">// 通知视图更新</span><br>    <span class="hljs-comment">//...重新渲染组件</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> [_state, setState]; <span class="hljs-comment">// 数组是新的变量，里面的每项自然也是新的，栈地址也不相同</span><br>&#125;<br><span class="hljs-keyword">let</span> [num1, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始时num1=0  setNum=setState 0x001</span><br><span class="hljs-title function_">setNum</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//=&gt;_state=100 通知视图更新</span><br><span class="hljs-comment">// ---</span><br>再次执行整个函数组件，在执行到useState的时候：<br><span class="hljs-keyword">let</span> [num2, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//由于初次渲染时，全局state被赋值了，不再为undefined，所以不再赋值为initialState</span><br>在内部又产生了一个新的setState，地址和之前不同，使用这次新的闭包作为父级上下文<br>最后返回新的state和新的setState并被声明为新的变量<br>num2=<span class="hljs-number">100</span>  setNum=setState <span class="hljs-number">0x002</span><br></code></pre></td></tr></table></figure><h4 id="例-1-前后-state-浅比较-true，不更新状态和视图"><a href="#例-1-前后-state-浅比较-true，不更新状态和视图" class="headerlink" title="例 1 前后 state 浅比较 true，不更新状态和视图"></a>例 1 前后 state 浅比较 true，不更新状态和视图</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UseStateDemo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">UseStateDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;RENDER&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(<span class="hljs-number">10</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UseStateDemo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UseStateDemo</span>;<br></code></pre></td></tr></table></figure><p>不更新视图和状态</p><h4 id="例-2-更新多次，最终值-11"><a href="#例-2-更新多次，最终值-11" class="headerlink" title="例 2 更新多次，最终值 11"></a>例 2 更新多次，最终值 11</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UseStateDemo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">UseStateDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;RENDER&quot;</span>);<br>  <span class="hljs-keyword">let</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>      <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setX</span>(x + <span class="hljs-number">1</span>);<br>      &#125;);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UseStateDemo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span>x:&#123;x&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handle&#125;</span>&gt;</span></span><br><span class="language-xml">        新增</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UseStateDemo</span>;<br></code></pre></td></tr></table></figure><p>render 两次（理论上是一次，这里是因为这些操作作用的都是一个闭包中的同一个状态值，在第一次改状态还没改成功之前，其他次操作访问的状态值仍旧是还没改的 10，直到第一次改状态成功，剩余次操作不会再通过 Object.is 的测试。这里 render 次数和浏览器的效率有关，不过绝对不是 10 次 ），最后状态值是 11</p><p><img src="/.io//6.png"></p><p>在第一次渲染时创造出来顶级的函数作用域，_state 私有属性就是在这个顶级作用域里面的</p><p>点击 handle 之后会执行 10 次同步清空更新队列的操作</p><p>在第一次 flushSync，更新队列里只有一个 setX，立即同步执行，使用的是第一次 Demo 创建出来的 EC 的闭包中的 state，也就是 10。进入 setX，通过了 Object.is 的比较，更新状态和视图，此时最外部的_state 也被更新为 11</p><p>第二次 flushSync，更新队列里只有一个 setX，立即同步执行，使用的也是第一次 Demo 创建出来的 EC 的闭包中的 state（因为这些 flushSync 方法都存在于第一个上下文中），也就是 10。进入 setX，未通过了 Object.is 的比较，因此不更新状态和视图</p><p>第三。。。十轮同样不更新</p><h4 id="例-3-更新-1-次，最终值-20-——函数式更新"><a href="#例-3-更新-1-次，最终值-20-——函数式更新" class="headerlink" title="例 3 更新 1 次，最终值 20 ——函数式更新"></a>例 3 更新 1 次，最终值 20 ——函数式更新</h4><p><img src="/.io//7.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>useImperativeHandle</title>
    <link href="/2023/06/21/useImperativeHandle/"/>
    <url>/2023/06/21/useImperativeHandle/</url>
    
    <content type="html"><![CDATA[<h3 id="useImperativeHandle-和-ref-转发"><a href="#useImperativeHandle-和-ref-转发" class="headerlink" title="useImperativeHandle 和 ref 转发"></a>useImperativeHandle 和 ref 转发</h3><p><strong>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值，应当与 forwardRef 一起使用，实现 ref 转发</strong></p><p><strong>我们获取类组件实例后，可以直接调用实例上的方法！</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  submit = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了子组件的submit方法！&quot;</span>);<br>  &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>           ...        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> box = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">current</span>); <span class="hljs-comment">//子组件的实例</span><br>    box.<span class="hljs-property">current</span>.<span class="hljs-title function_">submit</span>();<br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box&#125;</span> /&gt;</span>   </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是直接把 ref 赋值给函数组件，是不被允许的！</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>       ...    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> box = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">current</span>); <span class="hljs-comment">//null // Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</span><br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box&#125;</span> /&gt;</span>   </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>此时我们可以基于 forwardRef 和 useImperativeHandle , 就可以实现父组件调用子组件中的方法！</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;<br>  useEffect,<br>  useRef,<br>  useImperativeHandle,<br>  forwardRef,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">props, ref</span>) &#123;<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">submit</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了子组件的submit方法！&quot;</span>);<br>      &#125;,<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>       ...    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> box = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">current</span>);<br>    box.<span class="hljs-property">current</span>.<span class="hljs-title function_">submit</span>();<br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box&#125;</span> /&gt;</span>   </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useImperativeHandle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useRef深层剖析</title>
    <link href="/2023/06/19/useRef/"/>
    <url>/2023/06/19/useRef/</url>
    
    <content type="html"><![CDATA[<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><h4 id="ref-使用场景"><a href="#ref-使用场景" class="headerlink" title="ref 使用场景"></a>ref 使用场景</h4><p><strong>通常，当你的组件需要“跳出” React 并与外部 API 通信时，你会用到 ref —— 通常是不会影响组件外观的浏览器 API。以下是这些罕见情况中的几个：</strong></p><ul><li><strong>存储 <a href="https://developer.mozilla.org/docs/Web/API/setTimeout">timeout ID</a></strong></li><li><strong>存储和操作 <a href="https://developer.mozilla.org/docs/Web/API/Element">DOM 元素</a>，涉及非受控组件。赋值给标签，目的是获取 DOM 元素；赋值给类组件，目的是获取组件的实例；</strong></li><li><strong>存储不需要被用来计算 JSX 的其他对象。</strong></li></ul><p><strong>如果你的组件需要存储一些值，但不影响渲染逻辑，请选择 ref。</strong></p><h4 id="类组件的三种创建和使用方式"><a href="#类组件的三种创建和使用方式" class="headerlink" title="类组件的三种创建和使用方式"></a>类组件的三种创建和使用方式</h4><h5 id="方式一——字符串形式的-ref（过时了，未来版本可能移除，开发时不推荐使用，效率低）"><a href="#方式一——字符串形式的-ref（过时了，未来版本可能移除，开发时不推荐使用，效率低）" class="headerlink" title="方式一——字符串形式的 ref（过时了，未来版本可能移除，开发时不推荐使用，效率低）"></a>方式一——字符串形式的 ref（<strong>过时了，未来版本可能移除，开发时不推荐使用，效率低</strong>）</h5><p><strong>通过 <code>this.refs</code>访问</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">ref</span>=&quot;input1&quot;/&gt;<br></code></pre></td></tr></table></figure><h5 id="方式二——回调形式的-ref"><a href="#方式二——回调形式的-ref" class="headerlink" title="方式二——回调形式的 ref"></a>方式二——回调形式的 ref</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">React帮我们调用回调函数，并且将当前的DOM节点传入回调函数<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;input<br>  ref=&#123;<span class="hljs-function">(<span class="hljs-params">currentNode</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = currentNode;<br>  &#125;&#125;<br>/&gt;<br><span class="hljs-comment">// currentNode是当前所处的节点，也就是这个input</span><br></code></pre></td></tr></table></figure><p><strong>不能通过 <code>this.refs</code>访问，因为这些 ref 都成了实例属性</strong></p><p><strong>React 不会帮你执行未知属性的回调函数</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;input<br>  ref=&#123;<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = c)&#125;<br>  ahh=&#123;<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  &#125;&#125;<br>  type=<span class="hljs-string">&quot;text&quot;</span><br>  placeholder=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span><br>/&gt;<br></code></pre></td></tr></table></figure><p><strong>如果 ref 回调函数是以**<strong>内联函数的形式定义的，在更新过程中它会被执行两次</strong>，第一次传入参数 null，第二次传入参数 DOM 元素。这是因为在每次渲染时创建一个新的实例，所以 React 清空旧的 ref 并设置新的。通过</strong>将 ref 的回调函数定义成 class 的绑定函数<strong>的方式可以避免上述问题，但是</strong>大多数情况下它是无效的（无关紧要）**</p><h5 id="方式三——createRef-创建-ref-容器（最推荐）"><a href="#方式三——createRef-创建-ref-容器（最推荐）" class="headerlink" title="方式三——createRef 创建 ref 容器（最推荐）"></a>方式三——createRef 创建 ref 容器（<strong>最推荐</strong>）</h5><p><em>React.createRef 调用后可以返回一个容器，该容器可以存储被 ref 所标识的节点,该容器是“专人专用”的，多个 ref 的值可以相互独立</em></p><p><strong>ref 是实例的属性，不能通过 this.refs 访问</strong></p><p><strong>this.myRef.current 是当前引用的 DOM，this.myRef.current.value 是当前 DOM 的值</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">myRef</span> <span class="hljs-operator">=</span> React.createRef()<span class="hljs-comment">;</span><br>&lt;input ref<span class="hljs-operator">=</span>&#123;this.myRef&#125; /&gt;<br></code></pre></td></tr></table></figure><h4 id="hooks-组件通过-useRef-创建-ref-对象"><a href="#hooks-组件通过-useRef-创建-ref-对象" class="headerlink" title="hooks 组件通过 useRef 创建 ref 对象"></a>hooks 组件通过 useRef 创建 ref 对象</h4><p><strong>在函数组件中，可以基于</strong> <code>useRef</code>获取 DOM 元素！类似于类组件中的 ：</p><ul><li><strong>ref&#x3D;{x&#x3D;&gt;thix.box&#x3D;x}</strong></li><li><strong>React.createRef</strong></li></ul><p><strong>函数组件中创建 ref 对象的两种方法：</strong></p><ul><li><code>let box1 = useRef(null)</code></li><li><code>let box2 = React.createRef();</code></li></ul><p><strong>注意：</strong></p><p><strong>React.createRef 也是 ref 对象，在类组件和函数组件中都可以使用</strong></p><p><strong>useRef 只能在函数组件中使用，所有的 hooks 函数都只能在函数组件中使用，在类组件中使用会报错</strong></p><p><strong>ref 只能在 DOM 创建之后才能获取 DOM 元素，也就是说在 useLayoutEffect 阶段就可以使用</strong></p><h4 id="createRef-性能比-useRef-差——每次渲染创建新-ref-对象"><a href="#createRef-性能比-useRef-差——每次渲染创建新-ref-对象" class="headerlink" title="createRef 性能比 useRef 差——每次渲染创建新 ref 对象"></a>createRef 性能比 useRef 差——每次渲染创建新 ref 对象</h4><ul><li><strong>createRef 每次渲染都会返回一个新的引用</strong></li><li><strong>而 useRef 每次都会返回相同的引用</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./Demo.less&#x27;</span>;<br><br><span class="hljs-keyword">let</span> prev1,<br>    prev2;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 函数组件中创建ref对象的两种方法</span><br>    <span class="hljs-keyword">let</span> box1 = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>),<br>        box2 = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>    <span class="hljs-keyword">if</span> (!prev1) &#123;<br>        <span class="hljs-comment">// 第一次DEMO执行，把第一次创建的REF对象赋值给变量</span><br>        prev1 = box1;<br>        prev2 = box2;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 第二次DEMO执行，我们验证一下，新创建的REF对象，和之前第一次创建的REF对象，是否一致？</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prev1 === box1); <span class="hljs-comment">//true  useRef再每一次组件更新的时候（函数重新执行），再次执行useRef方法的时候，不会创建新的REF对象了，获取到的还是第一次创建的那个REF对象！！</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prev2 === box2); <span class="hljs-comment">//false createRef在每一次组件更新的时候，都会创建一个全新的REF对象出来，比较浪费性能！！</span><br>        <span class="hljs-comment">// 总结：在类组件中，创建REF对象，我们基于 React.createRef 处理；但是在函数组件中，为了保证性能，我们应该使用专属的 useRef 处理！！</span><br>    &#125;<br><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box1.<span class="hljs-property">current</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box2.<span class="hljs-property">current</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box1&#125;</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;box2&#125;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">                setNum(num + 1);</span><br><span class="language-xml">            &#125;&#125;&gt;</span><br><span class="language-xml">            新增</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>总结：在类组件中，创建 Ref 对象，基于 React.createRef 处理；在函数组件中为了保证性能使用 useRef</strong></p><h4 id="ref-的-DOM-用法总结【useRef】"><a href="#ref-的-DOM-用法总结【useRef】" class="headerlink" title="ref 的 DOM 用法总结【useRef】"></a>ref 的 DOM 用法总结【useRef】</h4><ul><li><strong>给元素标签设置 ref，目的：获取对应的 DOM 元素</strong></li><li><strong>给类组件设置 ref，目的：获取当前调用组件创建的实例（后续可以根据实例获取子组件中的相关信息）</strong><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 基于ref获取子组件的实例，这样基于实例，可以调用子组件内部，挂载到实例上的东西</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    state = &#123; x: <span class="hljs-number">1000</span> &#125;;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> &lt;div className=<span class="hljs-string">&quot;child-box&quot;</span>&gt;<br>            &#123;<span class="hljs-keyword">this</span>.state.x&#125;<br>        &lt;/div&gt;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>给函数组件&#x2F;hooks 设置 ref，直接报错：Function components cannot be given refs. Attempts to access this ref wil fail，但是可以配合 React.forwardRef 实现 ref 的转发。目的：获取函数子组件内的某个 DOM 元素</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 基于forwardRef实现ref转发，目的：获取子组件内部的某个元素</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">props, ref</span>) &#123;<br>    <span class="hljs-comment">// console.log(ref); //在DEMO中，调用Child的时候，传递的ref对象「x」</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;child-box&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useRef</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useLayoutEffect深层剖析</title>
    <link href="/2023/06/17/useLayoutEffect/"/>
    <url>/2023/06/17/useLayoutEffect/</url>
    
    <content type="html"><![CDATA[<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>useLayoutEffect 函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后<strong>同步</strong>调用 effect。</p><p>可以使用它来读取 DOM 布局并同步触发重渲染。</p><p>在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p><p>尽可能使用标准的 useLayoutEffect 以避免阻塞视觉更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect, useLayoutEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 再试试useLayoutEffect</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">let</span> random = +<span class="hljs-title class_">String</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()).<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-title function_">setNum</span>(random);<br>    &#125;<br>  &#125;, [num]);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">background:</span> &quot;<span class="hljs-attr">lightblue</span>&quot;,</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">WebkitUserSelect:</span> &quot;<span class="hljs-attr">none</span>&quot;,</span></span><br><span class="hljs-tag"><span class="language-xml">      &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setNum(0);</span><br><span class="language-xml">      &#125;&#125;</span><br><span class="language-xml">    &gt;</span><br><span class="language-xml">      &#123;num&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useEffect-和-useLayoutEffect-区别"><a href="#useEffect-和-useLayoutEffect-区别" class="headerlink" title="useEffect 和 useLayoutEffect 区别"></a>useEffect 和 useLayoutEffect 区别</h3><p><strong>useLayoutEffect 会阻塞浏览器渲染真实 DOM【真实 DOM 对象已经创建了】，优先执行 Effect 链表中的 callback；</strong></p><p><strong>useEffect 不会阻塞浏览器渲染真实 DOM，在渲染真实 DOM 的同时，去执行 Effect 链表中的 callback</strong></p><ul><li>它们里面的回调函数<strong>都是放在 effect 链表</strong>中的，但是 useLayoutEffect 设置的 callback 要<strong>优先</strong>于 useEffect 去执行</li><li>在两者设置的 callback 中，<strong>依然可以获取 DOM 元素</strong>「原因：真实 DOM 对象已经创建了，区别只是浏览器是否渲染」</li><li>如果在 callback 函数中又修改了状态值「视图又要更新」<ul><li>useEffect:浏览器肯定是把第一次的真实已经绘制了，再去渲染第二次真实 DOM【频繁切换有闪烁】</li><li>useLayoutEffect:浏览器是把两次真实 DOM 的渲染，<strong>合并在一起渲染</strong>的【频繁切换无闪烁】</li></ul></li></ul><h3 id="视图更新周期："><a href="#视图更新周期：" class="headerlink" title="视图更新周期："></a>视图更新周期：</h3><p><strong>第一步：基于 babel-preset-react-app 把 JSX 编译为 createElement 格式</strong></p><p><strong>第二步：执行 createElement(…)方法，创建出 virtualDOM</strong></p><p><strong>第三步：基于 root.render 方法把 virtualDOM 变为真实 DOM 对象「DOM-DIFF」</strong></p><pre><code class="hljs">**useLayoutEffect阻塞浏览器绘制：在整个视图渲染更新周期中，创建出真实DOM以后直接执行useLayoutEffect的effect链表中的方法。如果该方法有setXXX操作，那么会直接进入下一次更新周期中，而不会执行第四步。因此无论视图更新的过程执行了多少次，界面永远只看到了一次变化，即【频繁切换无闪烁】**</code></pre><p><strong>第四步：浏览器渲染和绘制真实 DOM 对象</strong></p><p><strong>useEffect 不阻塞浏览器绘制：在浏览器绘制完毕、第四步执行之后才会执行 effect 链表中的方法。如果该方法有 setXXX 操作，那么会直接进入下一次更新周期中。视图更新的过程执行了多少次，第四步就会执行多少次，浏览器就会渲染重绘多少次。由于浏览器绘制是需要一定时间的，因此对于速度较慢的设备，用户会看到多次重绘之间的“白屏”，即【频繁切换有闪烁】</strong></p><p><strong>从视图更新周期可以看出，useLayoutEffect 和 useEffect 都是可以获取真实 DOM 的时机</strong></p><h3 id="官方文档示例参考"><a href="#官方文档示例参考" class="headerlink" title="官方文档示例参考"></a>官方文档示例参考</h3><p><a href="https://react.docschina.org/reference/react/useLayoutEffect#usage">https://react.docschina.org/reference/react/useLayoutEffect#usage</a></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>useLayoutEffect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react hooks简介</title>
    <link href="/2023/06/01/Hooks%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/06/01/Hooks%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="React-组件回顾"><a href="#React-组件回顾" class="headerlink" title="React 组件回顾"></a>React 组件回顾</h2><h3 id="函数组件特点"><a href="#函数组件特点" class="headerlink" title="函数组件特点"></a>函数组件特点</h3><ul><li>不具备“状态、ref、周期函数”等内容，第一次渲染完毕后，无法基于组件内部的操作来控制其更新，因此称之为静态组件！</li><li>但是具备属性及插槽，父组件可以控制其重新渲染！</li><li>渲染流程简单，渲染速度较快！</li><li>基于 FP（函数式编程）思想设计，提供更细粒度的逻辑组织和复用！</li><li><strong>纯函数组件，无法改状态</strong></li></ul><h3 id="类组件特点"><a href="#类组件特点" class="headerlink" title="类组件特点"></a>类组件特点</h3><ul><li>具备“状态、ref、周期函数、属性、插槽”等内容，可以灵活的控制组件更新，基于钩子函数也可灵活掌控不同阶段处理不同的事情！</li><li>渲染流程繁琐，渲染速度相对较慢！</li><li>基于 OOP（面向对象编程）思想设计，更方便实现继承等！</li></ul><h3 id="React-Hooks-组件"><a href="#React-Hooks-组件" class="headerlink" title="React Hooks 组件"></a>React Hooks 组件</h3><p>就是基于 React 中新提供的 Hook 函数，可以 <code>让函数组件动态化</code>!</p><h2 id="Hook-函数概览"><a href="#Hook-函数概览" class="headerlink" title="Hook 函数概览"></a>Hook 函数概览</h2><p>Hook 是 React 16.8 的新增特性！并且只能运用到函数组件中！<br><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html">https://zh-hans.reactjs.org/docs/hooks-reference.html</a></p><ul><li>基础 Hook<ul><li><code>useState</code> 使用状态管理</li><li><code>useEffect</code> 使用周期函数</li><li><code>useContext</code> 使用上下文信息</li></ul></li><li>额外的 Hook<ul><li><code>useReducer</code> useState 的替代方案，借鉴 redux 处理思想，管理更复杂的状态和逻辑</li><li><code>useCallback</code> 构建缓存优化方案</li><li><code>useMemo</code> 构建缓存优化方案</li><li><code>useRef</code> 使用 ref 获取 DOM</li><li><code>useImperativeHandle</code> 配合 forwardRef（ref 转发）一起使用</li><li><code>useLayoutEffect</code> 与 useEffect 相同，但会在所有的 DOM 变更之后同步调用 effect</li><li>…</li></ul></li><li>自定义 Hook</li><li>……</li></ul>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
